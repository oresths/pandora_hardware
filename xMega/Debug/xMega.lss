
xMega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ace  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000038  00802000  00001ace  00001b62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000163  00802038  00802038  00001b9a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b9a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000003b0  00000000  00000000  00001bca  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006683  00000000  00000000  00001f7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000015f4  00000000  00000000  000085fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000187d  00000000  00000000  00009bf1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000824  00000000  00000000  0000b470  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002699  00000000  00000000  0000bc94  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001d26  00000000  00000000  0000e32d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000300  00000000  00000000  00010053  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 0f 01 	jmp	0x21e	; 0x21e <__ctors_end>
       4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
       8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
       c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      10:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      14:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      18:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      1c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      20:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      24:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      28:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      2c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      30:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      34:	0c 94 7c 0a 	jmp	0x14f8	; 0x14f8 <__vector_13>
      38:	0c 94 b1 0a 	jmp	0x1562	; 0x1562 <__vector_14>
      3c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      40:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      44:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      48:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      4c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      50:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      54:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      58:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      5c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      60:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      64:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      68:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      6c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      70:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      74:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      78:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      7c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      80:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      84:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      88:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      8c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      90:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      94:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      98:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      9c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      a0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      a4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      a8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      ac:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      b0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      b4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      b8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      bc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      c0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      c4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      c8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      cc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      d0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      d4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      d8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      dc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      e0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      e4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      e8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      ec:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      f0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      f4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      f8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
      fc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     100:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     104:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     108:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     10c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     110:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     114:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     118:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     11c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     120:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     124:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     128:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     12c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     130:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     134:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     138:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     13c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     140:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     144:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     148:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     14c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     150:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     154:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     158:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     15c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     160:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     164:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     168:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     16c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     170:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     174:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     178:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     17c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     180:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     184:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     188:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     18c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     190:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     194:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     198:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     19c:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1a0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1a4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1a8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1ac:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1b0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1b4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1b8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1bc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1c0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1c4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1c8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1cc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1d0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1d4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1d8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1dc:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1e0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1e4:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1e8:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1ec:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1f0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__bad_interrupt>
     1f4:	1f 05       	cpc	r17, r15
     1f6:	16 04       	cpc	r1, r6
     1f8:	20 05       	cpc	r18, r0
     1fa:	65 04       	cpc	r6, r5
     1fc:	94 04       	cpc	r9, r4
     1fe:	d3 04       	cpc	r13, r3
     200:	1f 05       	cpc	r17, r15
     202:	20 05       	cpc	r18, r0
     204:	1f 05       	cpc	r17, r15

00000206 <__trampolines_start>:
     206:	0c 94 20 05 	jmp	0xa40	; 0xa40 <SRF05tinyFSM+0x24e>
     20a:	0c 94 94 04 	jmp	0x928	; 0x928 <SRF05tinyFSM+0x136>
     20e:	0c 94 16 04 	jmp	0x82c	; 0x82c <SRF05tinyFSM+0x3a>
     212:	0c 94 65 04 	jmp	0x8ca	; 0x8ca <SRF05tinyFSM+0xd8>
     216:	0c 94 d3 04 	jmp	0x9a6	; 0x9a6 <SRF05tinyFSM+0x1b4>
     21a:	0c 94 1f 05 	jmp	0xa3e	; 0xa3e <SRF05tinyFSM+0x24c>

0000021e <__ctors_end>:
     21e:	11 24       	eor	r1, r1
     220:	1f be       	out	0x3f, r1	; 63
     222:	cf ef       	ldi	r28, 0xFF	; 255
     224:	cd bf       	out	0x3d, r28	; 61
     226:	df e3       	ldi	r29, 0x3F	; 63
     228:	de bf       	out	0x3e, r29	; 62
     22a:	00 e0       	ldi	r16, 0x00	; 0
     22c:	0c bf       	out	0x3c, r16	; 60
     22e:	18 be       	out	0x38, r1	; 56
     230:	19 be       	out	0x39, r1	; 57
     232:	1a be       	out	0x3a, r1	; 58
     234:	1b be       	out	0x3b, r1	; 59

00000236 <__do_copy_data>:
     236:	10 e2       	ldi	r17, 0x20	; 32
     238:	a0 e0       	ldi	r26, 0x00	; 0
     23a:	b0 e2       	ldi	r27, 0x20	; 32
     23c:	ee ec       	ldi	r30, 0xCE	; 206
     23e:	fa e1       	ldi	r31, 0x1A	; 26
     240:	00 e0       	ldi	r16, 0x00	; 0
     242:	0b bf       	out	0x3b, r16	; 59
     244:	02 c0       	rjmp	.+4      	; 0x24a <__do_copy_data+0x14>
     246:	07 90       	elpm	r0, Z+
     248:	0d 92       	st	X+, r0
     24a:	a8 33       	cpi	r26, 0x38	; 56
     24c:	b1 07       	cpc	r27, r17
     24e:	d9 f7       	brne	.-10     	; 0x246 <__do_copy_data+0x10>
     250:	1b be       	out	0x3b, r1	; 59

00000252 <__do_clear_bss>:
     252:	21 e2       	ldi	r18, 0x21	; 33
     254:	a8 e3       	ldi	r26, 0x38	; 56
     256:	b0 e2       	ldi	r27, 0x20	; 32
     258:	01 c0       	rjmp	.+2      	; 0x25c <.do_clear_bss_start>

0000025a <.do_clear_bss_loop>:
     25a:	1d 92       	st	X+, r1

0000025c <.do_clear_bss_start>:
     25c:	ab 39       	cpi	r26, 0x9B	; 155
     25e:	b2 07       	cpc	r27, r18
     260:	e1 f7       	brne	.-8      	; 0x25a <.do_clear_bss_loop>
     262:	0e 94 18 0a 	call	0x1430	; 0x1430 <main>
     266:	0c 94 65 0d 	jmp	0x1aca	; 0x1aca <_exit>

0000026a <__bad_interrupt>:
     26a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000026e <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     26e:	0f 93       	push	r16
     270:	cf 93       	push	r28
     272:	df 93       	push	r29
     274:	1f 92       	push	r1
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     27a:	2f b7       	in	r18, 0x3f	; 63
     27c:	29 83       	std	Y+1, r18	; 0x01
     27e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     280:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     282:	fc 01       	movw	r30, r24
     284:	08 ed       	ldi	r16, 0xD8	; 216
     286:	04 bf       	out	0x34, r16	; 52
     288:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     28a:	89 81       	ldd	r24, Y+1	; 0x01
     28c:	8f bf       	out	0x3f, r24	; 63
#endif
}
     28e:	0f 90       	pop	r0
     290:	df 91       	pop	r29
     292:	cf 91       	pop	r28
     294:	0f 91       	pop	r16
     296:	08 95       	ret

00000298 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     298:	66 23       	and	r22, r22
     29a:	11 f0       	breq	.+4      	; 0x2a0 <CLKSYS_XOSC_Config+0x8>
     29c:	90 e2       	ldi	r25, 0x20	; 32
     29e:	01 c0       	rjmp	.+2      	; 0x2a2 <CLKSYS_XOSC_Config+0xa>
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	84 2b       	or	r24, r20
     2a4:	89 2b       	or	r24, r25
     2a6:	80 93 52 00 	sts	0x0052, r24
     2aa:	08 95       	ret

000002ac <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
     2ac:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     2ae:	68 2b       	or	r22, r24
     2b0:	e0 e5       	ldi	r30, 0x50	; 80
     2b2:	f0 e0       	ldi	r31, 0x00	; 0
     2b4:	65 83       	std	Z+5, r22	; 0x05
     2b6:	08 95       	ret

000002b8 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     2b8:	e0 e5       	ldi	r30, 0x50	; 80
     2ba:	f0 e0       	ldi	r31, 0x00	; 0
     2bc:	20 81       	ld	r18, Z
     2be:	98 2f       	mov	r25, r24
     2c0:	90 95       	com	r25
     2c2:	92 23       	and	r25, r18
     2c4:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     2c6:	90 81       	ld	r25, Z
	return clkEnabled;
}
     2c8:	89 23       	and	r24, r25
     2ca:	08 95       	ret

000002cc <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
     2cc:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
     2ce:	81 e4       	ldi	r24, 0x41	; 65
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	0c 94 37 01 	jmp	0x26e	; 0x26e <CCPWrite>

000002d6 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     2d6:	1f 93       	push	r17
     2d8:	cf 93       	push	r28
     2da:	df 93       	push	r29
     2dc:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     2de:	c0 e4       	ldi	r28, 0x40	; 64
     2e0:	d0 e0       	ldi	r29, 0x00	; 0
     2e2:	68 81       	ld	r22, Y
     2e4:	68 7f       	andi	r22, 0xF8	; 248
     2e6:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
     2e8:	80 e4       	ldi	r24, 0x40	; 64
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 37 01 	call	0x26e	; 0x26e <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     2f0:	88 81       	ld	r24, Y
	return clkCtrl;
}
     2f2:	81 23       	and	r24, r17
     2f4:	df 91       	pop	r29
     2f6:	cf 91       	pop	r28
     2f8:	1f 91       	pop	r17
     2fa:	08 95       	ret

000002fc <TC0_ConfigClockSource>:
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
     2fc:	fc 01       	movw	r30, r24
     2fe:	20 81       	ld	r18, Z
     300:	20 7f       	andi	r18, 0xF0	; 240
     302:	62 2b       	or	r22, r18
     304:	60 83       	st	Z, r22
     306:	08 95       	ret

00000308 <TC0_ConfigWGM>:
 *  \param tc    Timer/Counter module instance.
 *  \param wgm   Waveform generation mode.
 */
void TC0_ConfigWGM( volatile TC0_t * tc, TC_WGMODE_t wgm )
{
	tc->CTRLB = ( tc->CTRLB & ~TC0_WGMODE_gm ) | wgm;
     308:	fc 01       	movw	r30, r24
     30a:	21 81       	ldd	r18, Z+1	; 0x01
     30c:	28 7f       	andi	r18, 0xF8	; 248
     30e:	62 2b       	or	r22, r18
     310:	61 83       	std	Z+1, r22	; 0x01
     312:	08 95       	ret

00000314 <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     314:	fc 01       	movw	r30, r24
     316:	26 81       	ldd	r18, Z+6	; 0x06
     318:	2c 7f       	andi	r18, 0xFC	; 252
     31a:	62 2b       	or	r22, r18
     31c:	66 83       	std	Z+6, r22	; 0x06
     31e:	08 95       	ret

00000320 <TWI_MasterInit>:
 */
void TWI_MasterInit(TWI_Master_t *twi,
                    TWI_t *module,
                    TWI_MASTER_INTLVL_t intLevel,
                    uint8_t baudRateRegisterSetting)
{
     320:	fc 01       	movw	r30, r24
	twi->interface = module;
     322:	60 83       	st	Z, r22
     324:	71 83       	std	Z+1, r23	; 0x01
	twi->interface->MASTER.CTRLA = intLevel |
     326:	48 63       	ori	r20, 0x38	; 56
     328:	db 01       	movw	r26, r22
     32a:	11 96       	adiw	r26, 0x01	; 1
     32c:	4c 93       	st	X, r20
	                               TWI_MASTER_RIEN_bm |
	                               TWI_MASTER_WIEN_bm |
	                               TWI_MASTER_ENABLE_bm;
	twi->interface->MASTER.BAUD = baudRateRegisterSetting;
     32e:	a0 81       	ld	r26, Z
     330:	b1 81       	ldd	r27, Z+1	; 0x01
     332:	15 96       	adiw	r26, 0x05	; 5
     334:	2c 93       	st	X, r18
	twi->interface->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
     336:	01 90       	ld	r0, Z+
     338:	f0 81       	ld	r31, Z
     33a:	e0 2d       	mov	r30, r0
     33c:	81 e0       	ldi	r24, 0x01	; 1
     33e:	84 83       	std	Z+4, r24	; 0x04
     340:	08 95       	ret

00000342 <TWI_MasterWriteRead>:
bool TWI_MasterWriteRead(TWI_Master_t *twi,
                         uint8_t address,
                         uint8_t *writeData,
                         uint8_t bytesToWrite,
                         uint8_t bytesToRead)
{
     342:	0f 93       	push	r16
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	fc 01       	movw	r30, r24
	/*Parameter sanity check. */
	if (bytesToWrite > TWIM_WRITE_BUFFER_SIZE) {
     34a:	29 30       	cpi	r18, 0x09	; 9
     34c:	50 f5       	brcc	.+84     	; 0x3a2 <TWI_MasterWriteRead+0x60>
		return false;
	}
	if (bytesToRead > TWIM_READ_BUFFER_SIZE) {
     34e:	05 31       	cpi	r16, 0x15	; 21
     350:	40 f5       	brcc	.+80     	; 0x3a2 <TWI_MasterWriteRead+0x60>
		return false;
	}

	/*Initiate transaction if bus is ready. */
	if (twi->status == TWIM_STATUS_READY) {
     352:	83 a1       	ldd	r24, Z+35	; 0x23
     354:	81 11       	cpse	r24, r1
     356:	25 c0       	rjmp	.+74     	; 0x3a2 <TWI_MasterWriteRead+0x60>

		twi->status = TWIM_STATUS_BUSY;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	83 a3       	std	Z+35, r24	; 0x23
		twi->result = TWIM_RESULT_UNKNOWN;
     35c:	14 a2       	std	Z+36, r1	; 0x24

		twi->address = address; //<<1;
     35e:	62 83       	std	Z+2, r22	; 0x02

		/* Fill write data buffer. */
		for (uint8_t bufferIndex=0; bufferIndex < bytesToWrite; bufferIndex++) {
     360:	da 01       	movw	r26, r20
     362:	8a 2f       	mov	r24, r26
     364:	84 1b       	sub	r24, r20
     366:	82 17       	cp	r24, r18
     368:	40 f4       	brcc	.+16     	; 0x37a <TWI_MasterWriteRead+0x38>
     36a:	ed 01       	movw	r28, r26
     36c:	c4 1b       	sub	r28, r20
     36e:	d5 0b       	sbc	r29, r21
			twi->writeData[bufferIndex] = writeData[bufferIndex];
     370:	8d 91       	ld	r24, X+
     372:	ce 0f       	add	r28, r30
     374:	df 1f       	adc	r29, r31
     376:	8b 83       	std	Y+3, r24	; 0x03
     378:	f4 cf       	rjmp	.-24     	; 0x362 <TWI_MasterWriteRead+0x20>
		}

		twi->bytesToWrite = bytesToWrite;
     37a:	27 8f       	std	Z+31, r18	; 0x1f
		twi->bytesToRead = bytesToRead;
     37c:	00 a3       	std	Z+32, r16	; 0x20
		twi->bytesWritten = 0;
     37e:	11 a2       	std	Z+33, r1	; 0x21
		twi->bytesRead = 0;
     380:	12 a2       	std	Z+34, r1	; 0x22

		/* If write command, send the START condition + Address +
		 * 'R/_W = 0'
		 */
		if (twi->bytesToWrite > 0) {
     382:	87 8d       	ldd	r24, Z+31	; 0x1f
     384:	88 23       	and	r24, r24
     386:	19 f0       	breq	.+6      	; 0x38e <TWI_MasterWriteRead+0x4c>
			uint8_t writeAddress = twi->address & ~0x01;
     388:	82 81       	ldd	r24, Z+2	; 0x02
     38a:	8e 7f       	andi	r24, 0xFE	; 254
     38c:	05 c0       	rjmp	.+10     	; 0x398 <TWI_MasterWriteRead+0x56>
		}

		/* If read command, send the START condition + Address +
		 * 'R/_W = 1'
		 */
		else if (twi->bytesToRead > 0) {
     38e:	80 a1       	ldd	r24, Z+32	; 0x20
     390:	88 23       	and	r24, r24
     392:	49 f0       	breq	.+18     	; 0x3a6 <TWI_MasterWriteRead+0x64>
			uint8_t readAddress = twi->address | 0x01;
     394:	82 81       	ldd	r24, Z+2	; 0x02
     396:	81 60       	ori	r24, 0x01	; 1
			twi->interface->MASTER.ADDR = readAddress;
     398:	01 90       	ld	r0, Z+
     39a:	f0 81       	ld	r31, Z
     39c:	e0 2d       	mov	r30, r0
     39e:	86 83       	std	Z+6, r24	; 0x06
     3a0:	02 c0       	rjmp	.+4      	; 0x3a6 <TWI_MasterWriteRead+0x64>
                         uint8_t bytesToWrite,
                         uint8_t bytesToRead)
{
	/*Parameter sanity check. */
	if (bytesToWrite > TWIM_WRITE_BUFFER_SIZE) {
		return false;
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	01 c0       	rjmp	.+2      	; 0x3a8 <TWI_MasterWriteRead+0x66>
		 */
		else if (twi->bytesToRead > 0) {
			uint8_t readAddress = twi->address | 0x01;
			twi->interface->MASTER.ADDR = readAddress;
		}
		return true;
     3a6:	81 e0       	ldi	r24, 0x01	; 1
	} else {
		return false;
	}
}
     3a8:	df 91       	pop	r29
     3aa:	cf 91       	pop	r28
     3ac:	0f 91       	pop	r16
     3ae:	08 95       	ret

000003b0 <TWI_MasterWrite>:
 */
bool TWI_MasterWrite(TWI_Master_t *twi,
                     uint8_t address,
                     uint8_t *writeData,
                     uint8_t bytesToWrite)
{
     3b0:	0f 93       	push	r16
	bool twi_status = TWI_MasterWriteRead(twi, address, writeData, bytesToWrite, 0);
     3b2:	00 e0       	ldi	r16, 0x00	; 0
     3b4:	0e 94 a1 01 	call	0x342	; 0x342 <TWI_MasterWriteRead>
	return twi_status;
}
     3b8:	0f 91       	pop	r16
     3ba:	08 95       	ret

000003bc <TWI_MasterArbitrationLostBusErrorHandler>:
 *  Handles TWI responses to lost arbitration and bus error.
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
     3bc:	fc 01       	movw	r30, r24
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
     3be:	a0 81       	ld	r26, Z
     3c0:	b1 81       	ldd	r27, Z+1	; 0x01
     3c2:	14 96       	adiw	r26, 0x04	; 4
     3c4:	8c 91       	ld	r24, X
     3c6:	14 97       	sbiw	r26, 0x04	; 4

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
     3c8:	82 ff       	sbrs	r24, 2
     3ca:	02 c0       	rjmp	.+4      	; 0x3d0 <TWI_MasterArbitrationLostBusErrorHandler+0x14>
		twi->result = TWIM_RESULT_BUS_ERROR;
     3cc:	94 e0       	ldi	r25, 0x04	; 4
     3ce:	01 c0       	rjmp	.+2      	; 0x3d2 <TWI_MasterArbitrationLostBusErrorHandler+0x16>
	}
	/* If arbitration lost. */
	else {
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
     3d0:	93 e0       	ldi	r25, 0x03	; 3
     3d2:	94 a3       	std	Z+36, r25	; 0x24
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
     3d4:	88 60       	ori	r24, 0x08	; 8
     3d6:	14 96       	adiw	r26, 0x04	; 4
     3d8:	8c 93       	st	X, r24

	twi->status = TWIM_STATUS_READY;
     3da:	13 a2       	std	Z+35, r1	; 0x23
     3dc:	08 95       	ret

000003de <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
     3e2:	fc 01       	movw	r30, r24
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
     3e4:	97 8d       	ldd	r25, Z+31	; 0x1f
	uint8_t bytesToRead   = twi->bytesToRead;
     3e6:	80 a1       	ldd	r24, Z+32	; 0x20

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
     3e8:	a0 81       	ld	r26, Z
     3ea:	b1 81       	ldd	r27, Z+1	; 0x01
     3ec:	14 96       	adiw	r26, 0x04	; 4
     3ee:	2c 91       	ld	r18, X
     3f0:	14 97       	sbiw	r26, 0x04	; 4
     3f2:	24 ff       	sbrs	r18, 4
     3f4:	05 c0       	rjmp	.+10     	; 0x400 <TWI_MasterWriteHandler+0x22>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
     3f6:	83 e0       	ldi	r24, 0x03	; 3
     3f8:	13 96       	adiw	r26, 0x03	; 3
     3fa:	8c 93       	st	X, r24
		twi->result = TWIM_RESULT_NACK_RECEIVED;
     3fc:	85 e0       	ldi	r24, 0x05	; 5
     3fe:	1a c0       	rjmp	.+52     	; 0x434 <TWI_MasterWriteHandler+0x56>
		twi->status = TWIM_STATUS_READY;
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
     400:	21 a1       	ldd	r18, Z+33	; 0x21
     402:	29 17       	cp	r18, r25
     404:	58 f4       	brcc	.+22     	; 0x41c <TWI_MasterWriteHandler+0x3e>
		uint8_t data = twi->writeData[twi->bytesWritten];
     406:	81 a1       	ldd	r24, Z+33	; 0x21
     408:	ef 01       	movw	r28, r30
     40a:	c8 0f       	add	r28, r24
     40c:	d1 1d       	adc	r29, r1
     40e:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
     410:	17 96       	adiw	r26, 0x07	; 7
     412:	8c 93       	st	X, r24
		++twi->bytesWritten;
     414:	81 a1       	ldd	r24, Z+33	; 0x21
     416:	8f 5f       	subi	r24, 0xFF	; 255
     418:	81 a3       	std	Z+33, r24	; 0x21
     41a:	0e c0       	rjmp	.+28     	; 0x438 <TWI_MasterWriteHandler+0x5a>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
     41c:	92 a1       	ldd	r25, Z+34	; 0x22
     41e:	98 17       	cp	r25, r24
     420:	28 f4       	brcc	.+10     	; 0x42c <TWI_MasterWriteHandler+0x4e>
		uint8_t readAddress = twi->address | 0x01;
     422:	82 81       	ldd	r24, Z+2	; 0x02
     424:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
     426:	16 96       	adiw	r26, 0x06	; 6
     428:	8c 93       	st	X, r24
     42a:	06 c0       	rjmp	.+12     	; 0x438 <TWI_MasterWriteHandler+0x5a>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
     42c:	83 e0       	ldi	r24, 0x03	; 3
     42e:	13 96       	adiw	r26, 0x03	; 3
     430:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	84 a3       	std	Z+36, r24	; 0x24
	twi->status = TWIM_STATUS_READY;
     436:	13 a2       	std	Z+35, r1	; 0x23
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
     438:	df 91       	pop	r29
     43a:	cf 91       	pop	r28
     43c:	08 95       	ret

0000043e <TWI_MasterReadHandler>:
 *  reading bytes from the TWI slave.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
     43e:	fc 01       	movw	r30, r24
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) {
     440:	82 a1       	ldd	r24, Z+34	; 0x22
     442:	a0 81       	ld	r26, Z
     444:	b1 81       	ldd	r27, Z+1	; 0x01
     446:	84 31       	cpi	r24, 0x14	; 20
     448:	60 f4       	brcc	.+24     	; 0x462 <TWI_MasterReadHandler+0x24>
		uint8_t data = twi->interface->MASTER.DATA;
     44a:	17 96       	adiw	r26, 0x07	; 7
     44c:	8c 91       	ld	r24, X
		twi->readData[twi->bytesRead] = data;
     44e:	92 a1       	ldd	r25, Z+34	; 0x22
     450:	df 01       	movw	r26, r30
     452:	a9 0f       	add	r26, r25
     454:	b1 1d       	adc	r27, r1
     456:	1b 96       	adiw	r26, 0x0b	; 11
     458:	8c 93       	st	X, r24
		twi->bytesRead++;
     45a:	82 a1       	ldd	r24, Z+34	; 0x22
     45c:	8f 5f       	subi	r24, 0xFF	; 255
     45e:	82 a3       	std	Z+34, r24	; 0x22
     460:	06 c0       	rjmp	.+12     	; 0x46e <TWI_MasterReadHandler+0x30>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
     462:	83 e0       	ldi	r24, 0x03	; 3
     464:	13 96       	adiw	r26, 0x03	; 3
     466:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
     468:	82 e0       	ldi	r24, 0x02	; 2
     46a:	84 a3       	std	Z+36, r24	; 0x24
	twi->status = TWIM_STATUS_READY;
     46c:	13 a2       	std	Z+35, r1	; 0x23
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
     46e:	80 a1       	ldd	r24, Z+32	; 0x20

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) {
     470:	92 a1       	ldd	r25, Z+34	; 0x22
     472:	a0 81       	ld	r26, Z
     474:	b1 81       	ldd	r27, Z+1	; 0x01
     476:	98 17       	cp	r25, r24
     478:	20 f4       	brcc	.+8      	; 0x482 <TWI_MasterReadHandler+0x44>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     47a:	82 e0       	ldi	r24, 0x02	; 2
     47c:	13 96       	adiw	r26, 0x03	; 3
     47e:	8c 93       	st	X, r24
     480:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
     482:	87 e0       	ldi	r24, 0x07	; 7
     484:	13 96       	adiw	r26, 0x03	; 3
     486:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	84 a3       	std	Z+36, r24	; 0x24
	twi->status = TWIM_STATUS_READY;
     48c:	13 a2       	std	Z+35, r1	; 0x23
     48e:	08 95       	ret

00000490 <TWI_MasterInterruptHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
     490:	dc 01       	movw	r26, r24
     492:	ed 91       	ld	r30, X+
     494:	fc 91       	ld	r31, X
     496:	24 81       	ldd	r18, Z+4	; 0x04
     498:	32 2f       	mov	r19, r18
     49a:	3c 70       	andi	r19, 0x0C	; 12

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
     49c:	11 f0       	breq	.+4      	; 0x4a2 <TWI_MasterInterruptHandler+0x12>
	    (currentStatus & TWI_MASTER_BUSERR_bm)) {

		TWI_MasterArbitrationLostBusErrorHandler(twi);
     49e:	0c 94 de 01 	jmp	0x3bc	; 0x3bc <TWI_MasterArbitrationLostBusErrorHandler>
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
     4a2:	26 fd       	sbrc	r18, 6
		TWI_MasterWriteHandler(twi);
     4a4:	0c 94 ef 01 	jmp	0x3de	; 0x3de <TWI_MasterWriteHandler>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
     4a8:	27 fd       	sbrc	r18, 7
		TWI_MasterReadHandler(twi);
     4aa:	0c 94 1f 02 	jmp	0x43e	; 0x43e <TWI_MasterReadHandler>
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
     4ae:	26 e0       	ldi	r18, 0x06	; 6
     4b0:	fc 01       	movw	r30, r24
     4b2:	24 a3       	std	Z+36, r18	; 0x24
	twi->status = TWIM_STATUS_READY;
     4b4:	13 a2       	std	Z+35, r1	; 0x23
     4b6:	08 95       	ret

000004b8 <init_uart>:

#include "usart_driver.h"

void init_uart(void)
{
	PORTD.OUTSET = PIN3_bm;     /* <TX high> */
     4b8:	e0 e6       	ldi	r30, 0x60	; 96
     4ba:	f6 e0       	ldi	r31, 0x06	; 6
     4bc:	88 e0       	ldi	r24, 0x08	; 8
     4be:	85 83       	std	Z+5, r24	; 0x05
	PORTD.DIRSET = PIN3_bm;     /* <And output> */
     4c0:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRCLR = PIN2_bm;     /* <RX is input> */
     4c2:	84 e0       	ldi	r24, 0x04	; 4
     4c4:	82 83       	std	Z+2, r24	; 0x02
	RS232.CTRLA = 0x00;		/* <0x00:No IRQ, 0x01:Enable Data Register Empty Interrupt Level > */
     4c6:	e0 ea       	ldi	r30, 0xA0	; 160
     4c8:	f9 e0       	ldi	r31, 0x09	; 9
     4ca:	13 82       	std	Z+3, r1	; 0x03
	RS232.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
     4cc:	88 e1       	ldi	r24, 0x18	; 24
     4ce:	84 83       	std	Z+4, r24	; 0x04
	RS232.CTRLC = 3|8;
     4d0:	8b e0       	ldi	r24, 0x0B	; 11
     4d2:	85 83       	std	Z+5, r24	; 0x05
	RS232.BAUDCTRLA = 131;	/* <12 9600//137 28800// FIXED 135 for 57600  //FIX 131 FOR 115200 WITH CLK2X=0 (((CPU_SPEED) / (16)) / USARTF0BAUDRATE) - 1; //value=207 for CLKper CPU_SPEED=32MHz and desired speed USARTF0BAUDRATE> */
     4d4:	83 e8       	ldi	r24, 0x83	; 131
     4d6:	86 83       	std	Z+6, r24	; 0x06
	RS232.BAUDCTRLB = 0xD0;	/* <4 9600//f0=-1 28800//D0=(-03) 115200//E0=(-2) 57600> */
     4d8:	80 ed       	ldi	r24, 0xD0	; 208
     4da:	87 83       	std	Z+7, r24	; 0x07
     4dc:	08 95       	ret

000004de <usart_putc>:
 *
 * This function gets as input a character and sends it over USART
 */
void usart_putc(char c)
{
	while (!(RS232.STATUS & USART_DREIF_bm));
     4de:	90 91 a1 09 	lds	r25, 0x09A1
     4e2:	95 ff       	sbrs	r25, 5
     4e4:	fc cf       	rjmp	.-8      	; 0x4de <usart_putc>
	RS232.DATA = c;
     4e6:	80 93 a0 09 	sts	0x09A0, r24
     4ea:	08 95       	ret

000004ec <WDT_EnableAndSetTimeout>:
 *
 *  \param  period  Watchdog Timer timeout period
 */
void WDT_EnableAndSetTimeout( WDT_PER_t period )
{
	uint8_t temp = WDT_ENABLE_bm | WDT_CEN_bm | period;
     4ec:	83 60       	ori	r24, 0x03	; 3
	CCP = CCP_IOREG_gc;
     4ee:	98 ed       	ldi	r25, 0xD8	; 216
     4f0:	94 bf       	out	0x34, r25	; 52
	WDT.CTRL = temp;
     4f2:	80 93 80 00 	sts	0x0080, r24

	/* Wait for WD to synchronize with new settings. */
	while(WDT_IsSyncBusy()){
     4f6:	80 91 82 00 	lds	r24, 0x0082
     4fa:	80 fd       	sbrc	r24, 0
     4fc:	fc cf       	rjmp	.-8      	; 0x4f6 <WDT_EnableAndSetTimeout+0xa>

	}
}
     4fe:	08 95       	ret

00000500 <init_encoder>:
 *	Email: glagloui@gmail.com
 */ 
#include "encoder.h"

void init_encoder(encoder_struct *encoder_)
{
     500:	fc 01       	movw	r30, r24
	SCL_PORT.DIR = (1<<SCL_PIN);								/*! <Set PortB_Pin0 as output -> SCL> */
     502:	a0 e0       	ldi	r26, 0x00	; 0
     504:	b6 e0       	ldi	r27, 0x06	; 6
     506:	82 e0       	ldi	r24, 0x02	; 2
     508:	8c 93       	st	X, r24
	SCL_PORT.OUT = (1<<SCL_PIN);								/*! <Set PortC_PIN0> */
     50a:	14 96       	adiw	r26, 0x04	; 4
     50c:	8c 93       	st	X, r24
     50e:	14 97       	sbiw	r26, 0x04	; 4
	DOUT_PORT.DIR = (0<<DOUT_PIN);
     510:	1c 92       	st	X, r1
	
	/*! <Initialize encoder values in encoder struct> */
	encoder_ -> encoder_value_decoded = 0;
     512:	14 82       	std	Z+4, r1	; 0x04
     514:	15 82       	std	Z+5, r1	; 0x05
	encoder_ -> encoder_value_encoded = 0;
     516:	12 82       	std	Z+2, r1	; 0x02
     518:	13 82       	std	Z+3, r1	; 0x03
	encoder_ -> encoder_value_degrees = 0;
     51a:	10 82       	st	Z, r1
     51c:	11 82       	std	Z+1, r1	; 0x01
     51e:	08 95       	ret

00000520 <read_encoder>:
}

uint16_t read_encoder(void){
	uint16_t read_value = 0;
	
	SCL_PORT.OUT &= ~(1<<SCL_PIN);	// First falling edge according to SSI protocol
     520:	80 91 04 06 	lds	r24, 0x0604
     524:	8d 7f       	andi	r24, 0xFD	; 253
     526:	80 93 04 06 	sts	0x0604, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     52a:	4a e0       	ldi	r20, 0x0A	; 10
     52c:	4a 95       	dec	r20
     52e:	f1 f7       	brne	.-4      	; 0x52c <read_encoder+0xc>
     530:	00 c0       	rjmp	.+0      	; 0x532 <read_encoder+0x12>
     532:	2a e0       	ldi	r18, 0x0A	; 10
     534:	30 e0       	ldi	r19, 0x00	; 0
	encoder_ -> encoder_value_degrees = 0;
	
}

uint16_t read_encoder(void){
	uint16_t read_value = 0;
     536:	80 e0       	ldi	r24, 0x00	; 0
     538:	90 e0       	ldi	r25, 0x00	; 0
	
	SCL_PORT.OUT &= ~(1<<SCL_PIN);	// First falling edge according to SSI protocol
	_delay_us(1);
	
	for(int i=0;i<NUMBER_OF_BITS;i++){
		read_value = (read_value<<1);
     53a:	88 0f       	add	r24, r24
     53c:	99 1f       	adc	r25, r25
		SCL_PORT.OUT |= (1<< SCL_PIN);		// Rising edge
     53e:	40 91 04 06 	lds	r20, 0x0604
     542:	42 60       	ori	r20, 0x02	; 2
     544:	40 93 04 06 	sts	0x0604, r20
     548:	4a e0       	ldi	r20, 0x0A	; 10
     54a:	4a 95       	dec	r20
     54c:	f1 f7       	brne	.-4      	; 0x54a <read_encoder+0x2a>
     54e:	00 c0       	rjmp	.+0      	; 0x550 <read_encoder+0x30>
		_delay_us(1);
		SCL_PORT.OUT &= ~(1<<SCL_PIN);
     550:	40 91 04 06 	lds	r20, 0x0604
     554:	4d 7f       	andi	r20, 0xFD	; 253
     556:	40 93 04 06 	sts	0x0604, r20
		if(DOUT_PORT.IN & (1<<DOUT_PIN))	//Maybe bit in the first falling edge is wrong according to Figure 1a in datasheet
     55a:	40 91 08 06 	lds	r20, 0x0608
     55e:	42 fd       	sbrc	r20, 2
		{
			//bit is set, set LSB of resultPIND 3 16
			read_value = read_value | 0x01;
     560:	81 60       	ori	r24, 0x01	; 1
     562:	4a e0       	ldi	r20, 0x0A	; 10
     564:	4a 95       	dec	r20
     566:	f1 f7       	brne	.-4      	; 0x564 <read_encoder+0x44>
     568:	00 c0       	rjmp	.+0      	; 0x56a <read_encoder+0x4a>
     56a:	21 50       	subi	r18, 0x01	; 1
     56c:	31 09       	sbc	r19, r1
	uint16_t read_value = 0;
	
	SCL_PORT.OUT &= ~(1<<SCL_PIN);	// First falling edge according to SSI protocol
	_delay_us(1);
	
	for(int i=0;i<NUMBER_OF_BITS;i++){
     56e:	21 15       	cp	r18, r1
     570:	31 05       	cpc	r19, r1
     572:	19 f7       	brne	.-58     	; 0x53a <read_encoder+0x1a>
			//bit is set, set LSB of resultPIND 3 16
			read_value = read_value | 0x01;
		}
		_delay_us(1);
	}
	SCL_PORT.OUT |= (1<< SCL_PIN);		// Rising edge
     574:	20 91 04 06 	lds	r18, 0x0604
     578:	22 60       	ori	r18, 0x02	; 2
     57a:	20 93 04 06 	sts	0x0604, r18
	
	return read_value;
}
     57e:	08 95       	ret

00000580 <gray_to_binary>:
}

uint16_t gray_to_binary(uint16_t num)
{
	uint16_t mask;
	for (mask = num >> 1; mask != 0; mask = mask >> 1)
     580:	9c 01       	movw	r18, r24
     582:	36 95       	lsr	r19
     584:	27 95       	ror	r18
     586:	21 15       	cp	r18, r1
     588:	31 05       	cpc	r19, r1
     58a:	19 f0       	breq	.+6      	; 0x592 <gray_to_binary+0x12>
	{
		num = num ^ mask;
     58c:	82 27       	eor	r24, r18
     58e:	93 27       	eor	r25, r19
     590:	f8 cf       	rjmp	.-16     	; 0x582 <gray_to_binary+0x2>
	}
	return num;
}
     592:	08 95       	ret

00000594 <get_encoder_values>:

/*
	Read encoder value and stores encoded, decoded, and degree values 
*/
void get_encoder_values(encoder_struct *encoder_)
{
     594:	0f 93       	push	r16
     596:	1f 93       	push	r17
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	ec 01       	movw	r28, r24
	uint16_t encoder_value_degrees;
	uint16_t encoder_value_encoded;
	uint16_t encoder_value_decoded;
	
	cli();																	/*! <Clear Global Interrupts for SCL generation> */
     59e:	f8 94       	cli
	encoder_value_encoded = read_encoder();
     5a0:	0e 94 90 02 	call	0x520	; 0x520 <read_encoder>
     5a4:	8c 01       	movw	r16, r24
	sei();																	/*! <Enable Global Interrupts> */
     5a6:	78 94       	sei
	encoder_value_decoded = gray_to_binary(encoder_value_encoded);
     5a8:	0e 94 c0 02 	call	0x580	; 0x580 <gray_to_binary>
	encoder_value_degrees = encoder_convert_degrees(encoder_value_decoded);
	
	encoder_ -> encoder_value_encoded = encoder_value_encoded;
     5ac:	0a 83       	std	Y+2, r16	; 0x02
     5ae:	1b 83       	std	Y+3, r17	; 0x03
	encoder_ -> encoder_value_decoded = encoder_value_decoded;
     5b0:	8c 83       	std	Y+4, r24	; 0x04
     5b2:	9d 83       	std	Y+5, r25	; 0x05
	return read_value;
}

uint16_t encoder_convert_degrees(uint16_t encoder_value){
	uint16_t encoder_degrees;
	encoder_degrees = encoder_value * 360 /1024;
     5b4:	48 e6       	ldi	r20, 0x68	; 104
     5b6:	51 e0       	ldi	r21, 0x01	; 1
     5b8:	84 9f       	mul	r24, r20
     5ba:	90 01       	movw	r18, r0
     5bc:	85 9f       	mul	r24, r21
     5be:	30 0d       	add	r19, r0
     5c0:	94 9f       	mul	r25, r20
     5c2:	30 0d       	add	r19, r0
     5c4:	11 24       	eor	r1, r1
     5c6:	83 2f       	mov	r24, r19
     5c8:	86 95       	lsr	r24
     5ca:	86 95       	lsr	r24
	encoder_value_decoded = gray_to_binary(encoder_value_encoded);
	encoder_value_degrees = encoder_convert_degrees(encoder_value_decoded);
	
	encoder_ -> encoder_value_encoded = encoder_value_encoded;
	encoder_ -> encoder_value_decoded = encoder_value_decoded;
	encoder_ -> encoder_value_degrees = encoder_value_degrees;
     5cc:	88 83       	st	Y, r24
     5ce:	19 82       	std	Y+1, r1	; 0x01
	
}
     5d0:	df 91       	pop	r29
     5d2:	cf 91       	pop	r28
     5d4:	1f 91       	pop	r17
     5d6:	0f 91       	pop	r16
     5d8:	08 95       	ret

000005da <pandora_fsm>:

void pandora_fsm(void)
{
	while(1)
	{
		if(TCTimingFlags & Tick200us)	/* <every 200us> */
     5da:	80 91 3c 20 	lds	r24, 0x203C
     5de:	80 ff       	sbrs	r24, 0
     5e0:	05 c0       	rjmp	.+10     	; 0x5ec <pandora_fsm+0x12>
		{
			TCTimingFlags&=~Tick200us; 
     5e2:	80 91 3c 20 	lds	r24, 0x203C
     5e6:	8e 7f       	andi	r24, 0xFE	; 254
     5e8:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 200us> */
		}
		if(TCTimingFlags & Tick400us)	/* <every 400us> */
     5ec:	80 91 3c 20 	lds	r24, 0x203C
     5f0:	81 ff       	sbrs	r24, 1
     5f2:	05 c0       	rjmp	.+10     	; 0x5fe <pandora_fsm+0x24>
		{
			TCTimingFlags&=~Tick400us; 
     5f4:	80 91 3c 20 	lds	r24, 0x203C
     5f8:	8d 7f       	andi	r24, 0xFD	; 253
     5fa:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 400us> */
		}
		if(TCTimingFlags & Tick1ms)		/* <every 1ms> */
     5fe:	80 91 3c 20 	lds	r24, 0x203C
     602:	82 ff       	sbrs	r24, 2
     604:	05 c0       	rjmp	.+10     	; 0x610 <pandora_fsm+0x36>
		{
			TCTimingFlags&=~Tick1ms; 
     606:	80 91 3c 20 	lds	r24, 0x203C
     60a:	8b 7f       	andi	r24, 0xFB	; 251
     60c:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 1ms> */
			//SensorWaitTimeHandler();							//Wait Time HANDLER OF SENSOR FSM (Timeout-Idle Timer-Revive Timer etc)
			//TWIWatchdog();
		}
		if(TCTimingFlags & Tick5ms)		/* <every 5ms> */
     610:	80 91 3c 20 	lds	r24, 0x203C
     614:	84 ff       	sbrs	r24, 4
     616:	0a c0       	rjmp	.+20     	; 0x62c <pandora_fsm+0x52>
		{
			TCTimingFlags&=~Tick5ms; 
     618:	80 91 3c 20 	lds	r24, 0x203C
     61c:	8f 7e       	andi	r24, 0xEF	; 239
     61e:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 5ms> */
			if(!(PCTXFlags&PCTX_Busy))	{CheckSensorBuffersForNewData();}
     622:	80 91 c0 20 	lds	r24, 0x20C0
     626:	80 ff       	sbrs	r24, 0
     628:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <CheckSensorBuffersForNewData>
		}
		if(TCTimingFlags & Tick10ms)	/* <every 10ms> */
     62c:	80 91 3c 20 	lds	r24, 0x203C
     630:	85 ff       	sbrs	r24, 5
     632:	05 c0       	rjmp	.+10     	; 0x63e <pandora_fsm+0x64>
		{
			TCTimingFlags&=~Tick10ms;
     634:	80 91 3c 20 	lds	r24, 0x203C
     638:	8f 7d       	andi	r24, 0xDF	; 223
     63a:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 10ms> */
		}
		if(TCTimingFlags & Tick50ms)	/* <every 50ms> */
     63e:	80 91 3c 20 	lds	r24, 0x203C
     642:	86 ff       	sbrs	r24, 6
     644:	05 c0       	rjmp	.+10     	; 0x650 <pandora_fsm+0x76>
		{
			TCTimingFlags&=~Tick50ms; 
     646:	80 91 3c 20 	lds	r24, 0x203C
     64a:	8f 7b       	andi	r24, 0xBF	; 191
     64c:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 50ms> */
		}
		if(TCTimingFlags & Tick100ms)	/* <every 100ms> */
     650:	80 91 3c 20 	lds	r24, 0x203C
     654:	87 ff       	sbrs	r24, 7
     656:	19 c0       	rjmp	.+50     	; 0x68a <pandora_fsm+0xb0>
		{
			TCTimingFlags&=~Tick100ms; 
     658:	80 91 3c 20 	lds	r24, 0x203C
     65c:	8f 77       	andi	r24, 0x7F	; 127
     65e:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 100ms> */
			/* <timestamp here?!> */
			_batteries.batteryVoltage_MOTOR = ADCB.CH0RES;					/* <Read 12 bit value and save as data> */
     662:	80 91 50 02 	lds	r24, 0x0250
     666:	90 91 51 02 	lds	r25, 0x0251
     66a:	80 93 d5 20 	sts	0x20D5, r24
     66e:	90 93 d6 20 	sts	0x20D6, r25
			_batteries.batteryVoltage_PSU = ADCB.CH1RES;					/* <Read 12 bit value and save as data> */
     672:	80 91 52 02 	lds	r24, 0x0252
     676:	90 91 53 02 	lds	r25, 0x0253
     67a:	80 93 d3 20 	sts	0x20D3, r24
     67e:	90 93 d4 20 	sts	0x20D4, r25
			get_encoder_values(&_encoder);
     682:	8d ec       	ldi	r24, 0xCD	; 205
     684:	90 e2       	ldi	r25, 0x20	; 32
     686:	0e 94 ca 02 	call	0x594	; 0x594 <get_encoder_values>
			
		}
		if(TCTimingFlags & Tick200ms)	/* <Every 200ms> */
     68a:	80 91 3c 20 	lds	r24, 0x203C
     68e:	83 ff       	sbrs	r24, 3
     690:	a4 cf       	rjmp	.-184    	; 0x5da <pandora_fsm>
		{
			TCTimingFlags&=~Tick200ms; 
     692:	80 91 3c 20 	lds	r24, 0x203C
     696:	87 7f       	andi	r24, 0xF7	; 247
     698:	80 93 3c 20 	sts	0x203C, r24
			/* <PUT HERE CODE TO BE SERVICED EVERY 200ms> */
			if(!(PCTXFlags&PCTX_Busy))
     69c:	80 91 c0 20 	lds	r24, 0x20C0
     6a0:	80 fd       	sbrc	r24, 0
     6a2:	9b cf       	rjmp	.-202    	; 0x5da <pandora_fsm>
			{
				PCTXPointer=0;
     6a4:	10 92 c5 20 	sts	0x20C5, r1
     6a8:	10 92 c6 20 	sts	0x20C6, r1
				PCTXFlags|=PCTX_Busy;
     6ac:	80 91 c0 20 	lds	r24, 0x20C0
     6b0:	81 60       	ori	r24, 0x01	; 1
     6b2:	80 93 c0 20 	sts	0x20C0, r24
				usart_putc(PCTXBuffer[0]);
     6b6:	e0 91 c3 20 	lds	r30, 0x20C3
     6ba:	f0 91 c4 20 	lds	r31, 0x20C4
     6be:	80 81       	ld	r24, Z
     6c0:	0e 94 6f 02 	call	0x4de	; 0x4de <usart_putc>
     6c4:	8a cf       	rjmp	.-236    	; 0x5da <pandora_fsm>

000006c6 <TWIWatchdog>:
 *	Two Wire Interface (I2C) software watchdog.
 *	
 */
void TWIWatchdog(void)
{
	TWIWatchdogTimer++;
     6c6:	80 91 39 20 	lds	r24, 0x2039
     6ca:	90 91 3a 20 	lds	r25, 0x203A
     6ce:	01 96       	adiw	r24, 0x01	; 1
     6d0:	80 93 39 20 	sts	0x2039, r24
     6d4:	90 93 3a 20 	sts	0x203A, r25
	if(TWIWatchdogTimer > TWIWatchdogTimeOut)
     6d8:	85 3f       	cpi	r24, 0xF5	; 245
     6da:	91 40       	sbci	r25, 0x01	; 1
     6dc:	14 f0       	brlt	.+4      	; 0x6e2 <TWIWatchdog+0x1c>
	{
		/* <PORTD.OUTTGL = 0x20;> */
		cli();									/* <Clear Global Interrupts> */
     6de:	f8 94       	cli
     6e0:	ff cf       	rjmp	.-2      	; 0x6e0 <TWIWatchdog+0x1a>
     6e2:	08 95       	ret

000006e4 <SensorWaitTimeHandler>:
 *
 *	Handle waiting time for "punished" sensors on I2C bus
 *	Decrease WaitCount1/ComRepeats/TimeForNextCycle if !0 
 */
void SensorWaitTimeHandler(void)		
{
     6e4:	e4 ee       	ldi	r30, 0xE4	; 228
     6e6:	f0 e2       	ldi	r31, 0x20	; 32
     6e8:	a5 ee       	ldi	r26, 0xE5	; 229
     6ea:	b0 e2       	ldi	r27, 0x20	; 32
		if(SensorModule[i].WaitCount2)	{SensorModule[i].WaitCount2--;}
		if(SensorModule[i].ComRepeats)	{SensorModule[i].ComRepeats--;}
		if(SensorModule[i].TimeForNextCycle)	{SensorModule[i].TimeForNextCycle--;}
		if((SensorModule[i].CurrentState==IdleState)&&(SensorModule[i].TimeForNextCycle==0))
		{
			SensorModule[i].CurrentState = FirstRunState;
     6ec:	21 e0       	ldi	r18, 0x01	; 1
 */
void SensorWaitTimeHandler(void)		
{
	for ( int i = 0 ; i < I2CSENSNUM; i++)
	{
		if(SensorModule[i].WaitCount1)	{SensorModule[i].WaitCount1--;}
     6ee:	84 81       	ldd	r24, Z+4	; 0x04
     6f0:	95 81       	ldd	r25, Z+5	; 0x05
     6f2:	00 97       	sbiw	r24, 0x00	; 0
     6f4:	19 f0       	breq	.+6      	; 0x6fc <SensorWaitTimeHandler+0x18>
     6f6:	01 97       	sbiw	r24, 0x01	; 1
     6f8:	84 83       	std	Z+4, r24	; 0x04
     6fa:	95 83       	std	Z+5, r25	; 0x05
		if(SensorModule[i].WaitCount2)	{SensorModule[i].WaitCount2--;}
     6fc:	86 81       	ldd	r24, Z+6	; 0x06
     6fe:	97 81       	ldd	r25, Z+7	; 0x07
     700:	00 97       	sbiw	r24, 0x00	; 0
     702:	19 f0       	breq	.+6      	; 0x70a <SensorWaitTimeHandler+0x26>
     704:	01 97       	sbiw	r24, 0x01	; 1
     706:	86 83       	std	Z+6, r24	; 0x06
     708:	97 83       	std	Z+7, r25	; 0x07
		if(SensorModule[i].ComRepeats)	{SensorModule[i].ComRepeats--;}
     70a:	80 85       	ldd	r24, Z+8	; 0x08
     70c:	91 85       	ldd	r25, Z+9	; 0x09
     70e:	00 97       	sbiw	r24, 0x00	; 0
     710:	19 f0       	breq	.+6      	; 0x718 <SensorWaitTimeHandler+0x34>
     712:	01 97       	sbiw	r24, 0x01	; 1
     714:	80 87       	std	Z+8, r24	; 0x08
     716:	91 87       	std	Z+9, r25	; 0x09
		if(SensorModule[i].TimeForNextCycle)	{SensorModule[i].TimeForNextCycle--;}
     718:	84 85       	ldd	r24, Z+12	; 0x0c
     71a:	95 85       	ldd	r25, Z+13	; 0x0d
     71c:	00 97       	sbiw	r24, 0x00	; 0
     71e:	19 f0       	breq	.+6      	; 0x726 <SensorWaitTimeHandler+0x42>
     720:	01 97       	sbiw	r24, 0x01	; 1
     722:	84 87       	std	Z+12, r24	; 0x0c
     724:	95 87       	std	Z+13, r25	; 0x0d
		if((SensorModule[i].CurrentState==IdleState)&&(SensorModule[i].TimeForNextCycle==0))
     726:	80 81       	ld	r24, Z
     728:	88 30       	cpi	r24, 0x08	; 8
     72a:	39 f4       	brne	.+14     	; 0x73a <SensorWaitTimeHandler+0x56>
     72c:	84 85       	ldd	r24, Z+12	; 0x0c
     72e:	95 85       	ldd	r25, Z+13	; 0x0d
     730:	89 2b       	or	r24, r25
     732:	19 f4       	brne	.+6      	; 0x73a <SensorWaitTimeHandler+0x56>
		{
			SensorModule[i].CurrentState = FirstRunState;
     734:	20 83       	st	Z, r18
			SensorModule[i].ComRepeats=0;
     736:	10 86       	std	Z+8, r1	; 0x08
     738:	11 86       	std	Z+9, r1	; 0x09
		}
		if((SensorModule[i].CurrentState==IdleState1)&&(SensorModule[i].WaitCount2==0))
     73a:	80 81       	ld	r24, Z
     73c:	86 30       	cpi	r24, 0x06	; 6
     73e:	31 f4       	brne	.+12     	; 0x74c <SensorWaitTimeHandler+0x68>
     740:	86 81       	ldd	r24, Z+6	; 0x06
     742:	97 81       	ldd	r25, Z+7	; 0x07
     744:	89 2b       	or	r24, r25
     746:	11 f4       	brne	.+4      	; 0x74c <SensorWaitTimeHandler+0x68>
			{SensorModule[i].CurrentState = SensorModule[i].RollBackState;}
     748:	8c 91       	ld	r24, X
     74a:	80 83       	st	Z, r24
		/* <If Revive time is over then start sensor again> */		
		if((SensorModule[i].CurrentState==ReviveState)&&(SensorModule[i].WaitCount1==0))
     74c:	80 81       	ld	r24, Z
     74e:	81 11       	cpse	r24, r1
     750:	09 c0       	rjmp	.+18     	; 0x764 <SensorWaitTimeHandler+0x80>
     752:	84 81       	ldd	r24, Z+4	; 0x04
     754:	95 81       	ldd	r25, Z+5	; 0x05
     756:	89 2b       	or	r24, r25
     758:	29 f4       	brne	.+10     	; 0x764 <SensorWaitTimeHandler+0x80>
		{
			SensorModule[i].TimeForNextCycle = 0;
     75a:	14 86       	std	Z+12, r1	; 0x0c
     75c:	15 86       	std	Z+13, r1	; 0x0d
			SensorModule[i].CurrentState = FirstRunState;
     75e:	20 83       	st	Z, r18
			SensorModule[i].ComRepeats = 0;
     760:	10 86       	std	Z+8, r1	; 0x08
     762:	11 86       	std	Z+9, r1	; 0x09
     764:	7f 96       	adiw	r30, 0x1f	; 31
     766:	5f 96       	adiw	r26, 0x1f	; 31
 *	Handle waiting time for "punished" sensors on I2C bus
 *	Decrease WaitCount1/ComRepeats/TimeForNextCycle if !0 
 */
void SensorWaitTimeHandler(void)		
{
	for ( int i = 0 ; i < I2CSENSNUM; i++)
     768:	81 e2       	ldi	r24, 0x21	; 33
     76a:	ef 37       	cpi	r30, 0x7F	; 127
     76c:	f8 07       	cpc	r31, r24
     76e:	09 f0       	breq	.+2      	; 0x772 <SensorWaitTimeHandler+0x8e>
     770:	be cf       	rjmp	.-132    	; 0x6ee <SensorWaitTimeHandler+0xa>
			SensorModule[i].TimeForNextCycle = 0;
			SensorModule[i].CurrentState = FirstRunState;
			SensorModule[i].ComRepeats = 0;
		}
	}
}
     772:	08 95       	ret

00000774 <SetSensorInReviveState>:
 *	Punish that sensor on a wait state.
 */
 
uint8_t SetSensorInReviveState(uint8_t SensorNumber)
{
	SensorModule[SensorNumber].ComErrorCounts++;
     774:	9f e1       	ldi	r25, 0x1F	; 31
     776:	89 9f       	mul	r24, r25
     778:	d0 01       	movw	r26, r0
     77a:	11 24       	eor	r1, r1
     77c:	fd 01       	movw	r30, r26
     77e:	e9 52       	subi	r30, 0x29	; 41
     780:	ff 4d       	sbci	r31, 0xDF	; 223
     782:	95 8d       	ldd	r25, Z+29	; 0x1d
     784:	9f 5f       	subi	r25, 0xFF	; 255
     786:	95 8f       	std	Z+29, r25	; 0x1d
	//SensorModule[SensorNumber].Status.Used = 1;
	SensorModule[SensorNumber].Status.I2CComErr = 1;
     788:	aa 51       	subi	r26, 0x1A	; 26
     78a:	bf 4d       	sbci	r27, 0xDF	; 223
     78c:	9c 91       	ld	r25, X
     78e:	90 62       	ori	r25, 0x20	; 32
     790:	9c 93       	st	X, r25
	SensorModule[SensorNumber].CurrentState = ReviveState;
     792:	15 86       	std	Z+13, r1	; 0x0d
	SensorModule[SensorNumber].WaitCount1 = SensorModule[SensorNumber].ReviveStateDuration;
     794:	27 89       	ldd	r18, Z+23	; 0x17
     796:	30 8d       	ldd	r19, Z+24	; 0x18
     798:	21 8b       	std	Z+17, r18	; 0x11
     79a:	32 8b       	std	Z+18, r19	; 0x12
	twiMaster.interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;								/* <reset I2C> */
     79c:	e0 91 72 21 	lds	r30, 0x2172
     7a0:	f0 91 73 21 	lds	r31, 0x2173
     7a4:	93 e0       	ldi	r25, 0x03	; 3
     7a6:	93 83       	std	Z+3, r25	; 0x03
	SensorNumber++;
	return SensorNumber;																	/* <Leave this sensor and check for the next one> */
}
     7a8:	8f 5f       	subi	r24, 0xFF	; 255
     7aa:	08 95       	ret

000007ac <TWIResultHandler>:
 *
 *	I2C bus results handler. Checks for bus errors and data transmission errors.
 */
uint8_t TWIResultHandler(uint8_t SensorNumber)
{
	switch (twiMaster.result)
     7ac:	90 91 96 21 	lds	r25, 0x2196
     7b0:	95 30       	cpi	r25, 0x05	; 5
     7b2:	28 f4       	brcc	.+10     	; 0x7be <TWIResultHandler+0x12>
     7b4:	92 30       	cpi	r25, 0x02	; 2
     7b6:	d8 f4       	brcc	.+54     	; 0x7ee <TWIResultHandler+0x42>
     7b8:	99 23       	and	r25, r25
     7ba:	31 f0       	breq	.+12     	; 0x7c8 <TWIResultHandler+0x1c>
     7bc:	08 95       	ret
     7be:	95 30       	cpi	r25, 0x05	; 5
     7c0:	19 f0       	breq	.+6      	; 0x7c8 <TWIResultHandler+0x1c>
     7c2:	96 30       	cpi	r25, 0x06	; 6
     7c4:	a1 f0       	breq	.+40     	; 0x7ee <TWIResultHandler+0x42>
     7c6:	08 95       	ret
	{
		case TWIM_RESULT_OK:
		break;
		case TWIM_RESULT_UNKNOWN:
		case TWIM_RESULT_NACK_RECEIVED:
			if(SensorModule[SensorNumber].ComRepeats>1)
     7c8:	9f e1       	ldi	r25, 0x1F	; 31
     7ca:	89 9f       	mul	r24, r25
     7cc:	f0 01       	movw	r30, r0
     7ce:	11 24       	eor	r1, r1
     7d0:	e9 52       	subi	r30, 0x29	; 41
     7d2:	ff 4d       	sbci	r31, 0xDF	; 223
     7d4:	25 89       	ldd	r18, Z+21	; 0x15
     7d6:	36 89       	ldd	r19, Z+22	; 0x16
     7d8:	22 30       	cpi	r18, 0x02	; 2
     7da:	31 05       	cpc	r19, r1
     7dc:	40 f0       	brcs	.+16     	; 0x7ee <TWIResultHandler+0x42>
			{
				/* <SensorModule[SensorNumber].CurrentState=SensorModule[SensorNumber].RollBackState;> */
				SensorModule[SensorNumber].CurrentState=IdleState1;
     7de:	96 e0       	ldi	r25, 0x06	; 6
     7e0:	95 87       	std	Z+13, r25	; 0x0d
				SensorModule[SensorNumber].WaitCount2=SensorModule[SensorNumber].IdleState1Duration;
     7e2:	23 8d       	ldd	r18, Z+27	; 0x1b
     7e4:	34 8d       	ldd	r19, Z+28	; 0x1c
     7e6:	23 8b       	std	Z+19, r18	; 0x13
     7e8:	34 8b       	std	Z+20, r19	; 0x14
				SensorNumber++;
     7ea:	8f 5f       	subi	r24, 0xFF	; 255
     7ec:	08 95       	ret
			break;
		case TWIM_RESULT_FAIL:
		case TWIM_RESULT_ARBITRATION_LOST:
		case TWIM_RESULT_BUFFER_OVERFLOW:
		case TWIM_RESULT_BUS_ERROR:
			SensorNumber=SetSensorInReviveState(SensorNumber);
     7ee:	0c 94 ba 03 	jmp	0x774	; 0x774 <SetSensorInReviveState>

000007f2 <SRF05tinyFSM>:
/*!< Brief function description
 *
 *	SRF05 Sonars Service FSM.
 */
uint8_t SRF05tinyFSM(uint8_t SensorNumber)
{
     7f2:	af 92       	push	r10
     7f4:	bf 92       	push	r11
     7f6:	df 92       	push	r13
     7f8:	ef 92       	push	r14
     7fa:	ff 92       	push	r15
     7fc:	0f 93       	push	r16
     7fe:	1f 93       	push	r17
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	d8 2e       	mov	r13, r24
	switch (SensorModule[SensorNumber].CurrentState){
     806:	c8 2f       	mov	r28, r24
     808:	d0 e0       	ldi	r29, 0x00	; 0
     80a:	4f e1       	ldi	r20, 0x1F	; 31
     80c:	84 9f       	mul	r24, r20
     80e:	f0 01       	movw	r30, r0
     810:	11 24       	eor	r1, r1
     812:	e9 52       	subi	r30, 0x29	; 41
     814:	ff 4d       	sbci	r31, 0xDF	; 223
     816:	45 85       	ldd	r20, Z+13	; 0x0d
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	49 30       	cpi	r20, 0x09	; 9
     81c:	51 05       	cpc	r21, r1
     81e:	08 f0       	brcs	.+2      	; 0x822 <SRF05tinyFSM+0x30>
     820:	0f c1       	rjmp	.+542    	; 0xa40 <SRF05tinyFSM+0x24e>
     822:	fa 01       	movw	r30, r20
     824:	e6 50       	subi	r30, 0x06	; 6
     826:	ff 4f       	sbci	r31, 0xFF	; 255
     828:	0c 94 38 0c 	jmp	0x1870	; 0x1870 <__tablejump2__>
//-------------------------------------------------------------------------------------------------------
		case FirstRunState:
		if ((SensorModule[SensorNumber].Status.Used)&&!(SensorModule[SensorNumber].Groupmember==0)){break;}
     82c:	8f e1       	ldi	r24, 0x1F	; 31
     82e:	8c 9f       	mul	r24, r28
     830:	f0 01       	movw	r30, r0
     832:	8d 9f       	mul	r24, r29
     834:	f0 0d       	add	r31, r0
     836:	11 24       	eor	r1, r1
     838:	df 01       	movw	r26, r30
     83a:	aa 51       	subi	r26, 0x1A	; 26
     83c:	bf 4d       	sbci	r27, 0xDF	; 223
     83e:	8c 91       	ld	r24, X
     840:	80 ff       	sbrs	r24, 0
     842:	05 c0       	rjmp	.+10     	; 0x84e <SRF05tinyFSM+0x5c>
     844:	e9 52       	subi	r30, 0x29	; 41
     846:	ff 4d       	sbci	r31, 0xDF	; 223
     848:	83 81       	ldd	r24, Z+3	; 0x03
     84a:	81 11       	cpse	r24, r1
     84c:	f9 c0       	rjmp	.+498    	; 0xa40 <SRF05tinyFSM+0x24e>
		if (twiMaster.status==TWIM_STATUS_READY)
     84e:	80 91 95 21 	lds	r24, 0x2195
     852:	81 11       	cpse	r24, r1
     854:	f5 c0       	rjmp	.+490    	; 0xa40 <SRF05tinyFSM+0x24e>
		{	
			TWI_MasterWrite(&twiMaster,
     856:	8f e1       	ldi	r24, 0x1F	; 31
     858:	8c 9f       	mul	r24, r28
     85a:	70 01       	movw	r14, r0
     85c:	8d 9f       	mul	r24, r29
     85e:	f0 0c       	add	r15, r0
     860:	11 24       	eor	r1, r1
     862:	87 01       	movw	r16, r14
     864:	09 52       	subi	r16, 0x29	; 41
     866:	1f 4d       	sbci	r17, 0xDF	; 223
     868:	d8 01       	movw	r26, r16
     86a:	14 96       	adiw	r26, 0x04	; 4
     86c:	4d 91       	ld	r20, X+
     86e:	5c 91       	ld	r21, X
     870:	15 97       	sbiw	r26, 0x05	; 5
     872:	21 e0       	ldi	r18, 0x01	; 1
     874:	12 96       	adiw	r26, 0x02	; 2
     876:	6c 91       	ld	r22, X
     878:	82 e7       	ldi	r24, 0x72	; 114
     87a:	91 e2       	ldi	r25, 0x21	; 33
     87c:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <TWI_MasterWrite>
							SensorModule[SensorNumber].SlaveAddress,
							(SensorModule[SensorNumber].WriteBufer+0),
							1);
			SensorModule[SensorNumber].Status.Used=1;
     880:	f7 01       	movw	r30, r14
     882:	ea 51       	subi	r30, 0x1A	; 26
     884:	ff 4d       	sbci	r31, 0xDF	; 223
     886:	80 81       	ld	r24, Z
			SensorModule[SensorNumber].Status.I2CComErr=0;
     888:	81 60       	ori	r24, 0x01	; 1
     88a:	8f 7d       	andi	r24, 0xDF	; 223
     88c:	80 83       	st	Z, r24
			SensorModule[SensorNumber].WaitCount1=SRF05tinyWaitForBusTimeOut;				/* <Preset TimeOut for this communication> */
     88e:	8f e0       	ldi	r24, 0x0F	; 15
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	f8 01       	movw	r30, r16
     894:	81 8b       	std	Z+17, r24	; 0x11
     896:	92 8b       	std	Z+18, r25	; 0x12
			if(SensorModule[SensorNumber].ComRepeats==0)
     898:	85 89       	ldd	r24, Z+21	; 0x15
     89a:	96 89       	ldd	r25, Z+22	; 0x16
     89c:	89 2b       	or	r24, r25
     89e:	21 f4       	brne	.+8      	; 0x8a8 <SRF05tinyFSM+0xb6>
				{SensorModule[SensorNumber].ComRepeats=SRF05tinyComRepeatTimeOut;}			/* <Preset TimeOut for handling Nack and other collisions> */
     8a0:	8e e1       	ldi	r24, 0x1E	; 30
     8a2:	90 e0       	ldi	r25, 0x00	; 0
     8a4:	85 8b       	std	Z+21, r24	; 0x15
     8a6:	96 8b       	std	Z+22, r25	; 0x16
			SensorModule[SensorNumber].RollBackState=FirstRunState;							/* <Repeat State on NACK> */
     8a8:	8f e1       	ldi	r24, 0x1F	; 31
     8aa:	8c 9f       	mul	r24, r28
     8ac:	f0 01       	movw	r30, r0
     8ae:	8d 9f       	mul	r24, r29
     8b0:	f0 0d       	add	r31, r0
     8b2:	11 24       	eor	r1, r1
     8b4:	e9 52       	subi	r30, 0x29	; 41
     8b6:	ff 4d       	sbci	r31, 0xDF	; 223
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	86 87       	std	Z+14, r24	; 0x0e
			SensorModule[SensorNumber].CurrentState=FirstCommunicationStateWait;			/* <Determine next state: Wait for measurements> */
     8bc:	83 e0       	ldi	r24, 0x03	; 3
     8be:	85 87       	std	Z+13, r24	; 0x0d
			SensorModule[SensorNumber].TimeForNextCycle=SRF05tinyCommunicationCycle;		/* <Preset Time until next Communication> */
     8c0:	84 e6       	ldi	r24, 0x64	; 100
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	81 8f       	std	Z+25, r24	; 0x19
     8c6:	92 8f       	std	Z+26, r25	; 0x1a
     8c8:	bb c0       	rjmp	.+374    	; 0xa40 <SRF05tinyFSM+0x24e>
		}
		break;
//----------------------------------------------------------------------------------------------------
		case FirstCommunicationStateWait:
		if((twiMaster.status == TWIM_STATUS_BUSY))
     8ca:	80 91 95 21 	lds	r24, 0x2195
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	c9 f4       	brne	.+50     	; 0x904 <SRF05tinyFSM+0x112>
		{
			/* <If communication timed out> */
			if (SensorModule[SensorNumber].WaitCount1== 0)
     8d2:	8f e1       	ldi	r24, 0x1F	; 31
     8d4:	8c 9f       	mul	r24, r28
     8d6:	f0 01       	movw	r30, r0
     8d8:	8d 9f       	mul	r24, r29
     8da:	f0 0d       	add	r31, r0
     8dc:	11 24       	eor	r1, r1
     8de:	e9 52       	subi	r30, 0x29	; 41
     8e0:	ff 4d       	sbci	r31, 0xDF	; 223
     8e2:	81 89       	ldd	r24, Z+17	; 0x11
     8e4:	92 89       	ldd	r25, Z+18	; 0x12
     8e6:	89 2b       	or	r24, r25
     8e8:	09 f0       	breq	.+2      	; 0x8ec <SRF05tinyFSM+0xfa>
     8ea:	aa c0       	rjmp	.+340    	; 0xa40 <SRF05tinyFSM+0x24e>
				/* <Put this sensor in revive state and check the next sensor> */									
				{SensorNumber=SetSensorInReviveState(SensorNumber);}						
     8ec:	8d 2d       	mov	r24, r13
		break;
		default:
		break;
	}
	return SensorNumber;
}
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	ff 90       	pop	r15
     8f8:	ef 90       	pop	r14
     8fa:	df 90       	pop	r13
     8fc:	bf 90       	pop	r11
     8fe:	af 90       	pop	r10
		if((twiMaster.status == TWIM_STATUS_BUSY))
		{
			/* <If communication timed out> */
			if (SensorModule[SensorNumber].WaitCount1== 0)
				/* <Put this sensor in revive state and check the next sensor> */									
				{SensorNumber=SetSensorInReviveState(SensorNumber);}						
     900:	0c 94 ba 03 	jmp	0x774	; 0x774 <SetSensorInReviveState>
		}
		else
		{
			SensorNumber=TWIResultHandler(SensorNumber);									/* <Check TWI result status, and prepare repeat or revive> */
     904:	8d 2d       	mov	r24, r13
     906:	0e 94 d6 03 	call	0x7ac	; 0x7ac <TWIResultHandler>
     90a:	d8 2e       	mov	r13, r24
			if (twiMaster.result == TWIM_RESULT_OK)											/* <If result status ok change to "Copy Data from TWI to Sensor Structure" STATE> */
     90c:	80 91 96 21 	lds	r24, 0x2196
     910:	81 30       	cpi	r24, 0x01	; 1
     912:	09 f0       	breq	.+2      	; 0x916 <SRF05tinyFSM+0x124>
     914:	95 c0       	rjmp	.+298    	; 0xa40 <SRF05tinyFSM+0x24e>
			{
				/* <Leave this sensor and check the next> */
				SensorModule[SensorNumber].CurrentState = SecondCommunicationState;
     916:	4f e1       	ldi	r20, 0x1F	; 31
     918:	d4 9e       	mul	r13, r20
     91a:	f0 01       	movw	r30, r0
     91c:	11 24       	eor	r1, r1
     91e:	e9 52       	subi	r30, 0x29	; 41
     920:	ff 4d       	sbci	r31, 0xDF	; 223
     922:	84 e0       	ldi	r24, 0x04	; 4
     924:	85 87       	std	Z+13, r24	; 0x0d
     926:	8b c0       	rjmp	.+278    	; 0xa3e <SRF05tinyFSM+0x24c>
			}														
		}
		break;
//-------------------------------------------------------------------------------------------------------
		case SecondCommunicationState:
		if (twiMaster.status==TWIM_STATUS_READY)
     928:	80 91 95 21 	lds	r24, 0x2195
     92c:	81 11       	cpse	r24, r1
     92e:	88 c0       	rjmp	.+272    	; 0xa40 <SRF05tinyFSM+0x24e>
		{	
			TWI_MasterWriteRead(&twiMaster,
     930:	8f e1       	ldi	r24, 0x1F	; 31
     932:	8c 9f       	mul	r24, r28
     934:	50 01       	movw	r10, r0
     936:	8d 9f       	mul	r24, r29
     938:	b0 0c       	add	r11, r0
     93a:	11 24       	eor	r1, r1
     93c:	c5 01       	movw	r24, r10
     93e:	89 52       	subi	r24, 0x29	; 41
     940:	9f 4d       	sbci	r25, 0xDF	; 223
     942:	7c 01       	movw	r14, r24
     944:	dc 01       	movw	r26, r24
     946:	14 96       	adiw	r26, 0x04	; 4
     948:	4d 91       	ld	r20, X+
     94a:	5c 91       	ld	r21, X
     94c:	15 97       	sbiw	r26, 0x05	; 5
     94e:	4f 5f       	subi	r20, 0xFF	; 255
     950:	5f 4f       	sbci	r21, 0xFF	; 255
     952:	19 96       	adiw	r26, 0x09	; 9
     954:	0c 91       	ld	r16, X
     956:	19 97       	sbiw	r26, 0x09	; 9
     958:	21 e0       	ldi	r18, 0x01	; 1
     95a:	12 96       	adiw	r26, 0x02	; 2
     95c:	6c 91       	ld	r22, X
     95e:	82 e7       	ldi	r24, 0x72	; 114
     960:	91 e2       	ldi	r25, 0x21	; 33
     962:	0e 94 a1 01 	call	0x342	; 0x342 <TWI_MasterWriteRead>
								SensorModule[SensorNumber].SlaveAddress,
								SensorModule[SensorNumber].WriteBufer+1,
								1,														/* send only 1st data of WriteBufer (value=0) to set internal PC of SRF to 0 */
								SensorModule[SensorNumber].ReadBufLen);					/* <Read all 4 (ReadBufLen=4) bytes from SRF235 (Ver,Unused,DataHigh,DataLow)> */
			SensorModule[SensorNumber].Status.I2CComErr=0;
     966:	f5 01       	movw	r30, r10
     968:	ea 51       	subi	r30, 0x1A	; 26
     96a:	ff 4d       	sbci	r31, 0xDF	; 223
     96c:	80 81       	ld	r24, Z
     96e:	8f 7d       	andi	r24, 0xDF	; 223
     970:	80 83       	st	Z, r24
			SensorModule[SensorNumber].WaitCount1=SRF05tinyWaitForBusTimeOut;
     972:	8f e0       	ldi	r24, 0x0F	; 15
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	f7 01       	movw	r30, r14
     978:	81 8b       	std	Z+17, r24	; 0x11
     97a:	92 8b       	std	Z+18, r25	; 0x12
			if(SensorModule[SensorNumber].ComRepeats==0)
     97c:	85 89       	ldd	r24, Z+21	; 0x15
     97e:	96 89       	ldd	r25, Z+22	; 0x16
     980:	89 2b       	or	r24, r25
     982:	21 f4       	brne	.+8      	; 0x98c <SRF05tinyFSM+0x19a>
				{SensorModule[SensorNumber].ComRepeats=SRF05tinyComRepeatTimeOut;}
     984:	8e e1       	ldi	r24, 0x1E	; 30
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	85 8b       	std	Z+21, r24	; 0x15
     98a:	96 8b       	std	Z+22, r25	; 0x16
			SensorModule[SensorNumber].RollBackState=SecondCommunicationState;
     98c:	8f e1       	ldi	r24, 0x1F	; 31
     98e:	8c 9f       	mul	r24, r28
     990:	f0 01       	movw	r30, r0
     992:	8d 9f       	mul	r24, r29
     994:	f0 0d       	add	r31, r0
     996:	11 24       	eor	r1, r1
     998:	e9 52       	subi	r30, 0x29	; 41
     99a:	ff 4d       	sbci	r31, 0xDF	; 223
     99c:	84 e0       	ldi	r24, 0x04	; 4
     99e:	86 87       	std	Z+14, r24	; 0x0e
			SensorModule[SensorNumber].CurrentState=SecondCommunicationStateWait;
     9a0:	85 e0       	ldi	r24, 0x05	; 5
     9a2:	85 87       	std	Z+13, r24	; 0x0d
     9a4:	4d c0       	rjmp	.+154    	; 0xa40 <SRF05tinyFSM+0x24e>
		}
		break;
//-------------------------------------------------------------------------------------------------------
		case SecondCommunicationStateWait:
		if((twiMaster.status == TWIM_STATUS_BUSY) /*&& (twiMaster.result == TWIM_RESULT_OK)*/)
     9a6:	80 91 95 21 	lds	r24, 0x2195
     9aa:	81 30       	cpi	r24, 0x01	; 1
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <SRF05tinyFSM+0x1be>
     9ae:	91 cf       	rjmp	.-222    	; 0x8d2 <SRF05tinyFSM+0xe0>
			if (SensorModule[SensorNumber].WaitCount1== 0)								/* <If communication timed out> */
				{SensorNumber=SetSensorInReviveState(SensorNumber);}					/* <Put this sensor in revive state and check the next sensor> */
		}
		else
		{
			SensorNumber=TWIResultHandler(SensorNumber);								/* <Check TWI result status, and prepare Repeat or Revive States> */
     9b0:	8d 2d       	mov	r24, r13
     9b2:	0e 94 d6 03 	call	0x7ac	; 0x7ac <TWIResultHandler>
     9b6:	d8 2e       	mov	r13, r24
			if (twiMaster.result == TWIM_RESULT_OK)										/* <If result status flag is active> */
     9b8:	80 91 96 21 	lds	r24, 0x2196
     9bc:	81 30       	cpi	r24, 0x01	; 1
     9be:	09 f0       	breq	.+2      	; 0x9c2 <SRF05tinyFSM+0x1d0>
     9c0:	3f c0       	rjmp	.+126    	; 0xa40 <SRF05tinyFSM+0x24e>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
			{
				for(int j = 0; j < SensorModule[SensorNumber].ReadBufLen; j++)			/* <Loop to copy data> */
     9c6:	ff e1       	ldi	r31, 0x1F	; 31
     9c8:	df 9e       	mul	r13, r31
     9ca:	c0 01       	movw	r24, r0
     9cc:	11 24       	eor	r1, r1
     9ce:	fc 01       	movw	r30, r24
     9d0:	e9 52       	subi	r30, 0x29	; 41
     9d2:	ff 4d       	sbci	r31, 0xDF	; 223
     9d4:	8f 01       	movw	r16, r30
     9d6:	07 5f       	subi	r16, 0xF7	; 247
     9d8:	1f 4f       	sbci	r17, 0xFF	; 255
					{SensorModule[SensorNumber].ReadBufer[j]=twiMaster.readData[j];}	/* <Copy data from MastersHandler Buffer to Sensors Software Module Buffer> */
     9da:	bf 01       	movw	r22, r30
     9dc:	69 5f       	subi	r22, 0xF9	; 249
     9de:	7f 4f       	sbci	r23, 0xFF	; 255
		else
		{
			SensorNumber=TWIResultHandler(SensorNumber);								/* <Check TWI result status, and prepare Repeat or Revive States> */
			if (twiMaster.result == TWIM_RESULT_OK)										/* <If result status flag is active> */
			{
				for(int j = 0; j < SensorModule[SensorNumber].ReadBufLen; j++)			/* <Loop to copy data> */
     9e0:	d8 01       	movw	r26, r16
     9e2:	4c 91       	ld	r20, X
     9e4:	50 e0       	ldi	r21, 0x00	; 0
     9e6:	24 17       	cp	r18, r20
     9e8:	35 07       	cpc	r19, r21
     9ea:	74 f4       	brge	.+28     	; 0xa08 <SRF05tinyFSM+0x216>
					{SensorModule[SensorNumber].ReadBufer[j]=twiMaster.readData[j];}	/* <Copy data from MastersHandler Buffer to Sensors Software Module Buffer> */
     9ec:	d9 01       	movw	r26, r18
     9ee:	ae 58       	subi	r26, 0x8E	; 142
     9f0:	be 4d       	sbci	r27, 0xDE	; 222
     9f2:	1b 96       	adiw	r26, 0x0b	; 11
     9f4:	4c 91       	ld	r20, X
     9f6:	eb 01       	movw	r28, r22
     9f8:	a8 81       	ld	r26, Y
     9fa:	b9 81       	ldd	r27, Y+1	; 0x01
     9fc:	a2 0f       	add	r26, r18
     9fe:	b3 1f       	adc	r27, r19
     a00:	4c 93       	st	X, r20
		else
		{
			SensorNumber=TWIResultHandler(SensorNumber);								/* <Check TWI result status, and prepare Repeat or Revive States> */
			if (twiMaster.result == TWIM_RESULT_OK)										/* <If result status flag is active> */
			{
				for(int j = 0; j < SensorModule[SensorNumber].ReadBufLen; j++)			/* <Loop to copy data> */
     a02:	2f 5f       	subi	r18, 0xFF	; 255
     a04:	3f 4f       	sbci	r19, 0xFF	; 255
     a06:	ec cf       	rjmp	.-40     	; 0x9e0 <SRF05tinyFSM+0x1ee>
					{SensorModule[SensorNumber].ReadBufer[j]=twiMaster.readData[j];}	/* <Copy data from MastersHandler Buffer to Sensors Software Module Buffer> */
				SensorModule[SensorNumber].ComRepeats=0;
     a08:	15 8a       	std	Z+21, r1	; 0x15
     a0a:	16 8a       	std	Z+22, r1	; 0x16
				if(SensorModule[SensorNumber].ReadBufer[0] & 0x08)						/* <if SRF04Tiny in internal busy state then repeat communication> */
     a0c:	a7 81       	ldd	r26, Z+7	; 0x07
     a0e:	b0 85       	ldd	r27, Z+8	; 0x08
     a10:	2c 91       	ld	r18, X
     a12:	23 ff       	sbrs	r18, 3
     a14:	03 c0       	rjmp	.+6      	; 0xa1c <SRF05tinyFSM+0x22a>
					{SensorModule[SensorNumber].CurrentState = SecondCommunicationState;}
     a16:	84 e0       	ldi	r24, 0x04	; 4
     a18:	85 87       	std	Z+13, r24	; 0x0d
     a1a:	0b c0       	rjmp	.+22     	; 0xa32 <SRF05tinyFSM+0x240>
				else
				{
					SensorModule[SensorNumber].CurrentState = IdleState;
     a1c:	28 e0       	ldi	r18, 0x08	; 8
     a1e:	25 87       	std	Z+13, r18	; 0x0d
					if(SensorModule[SensorNumber].ReadBufer[0] & 1)						/* <Check for new measurement captures> */
     a20:	2c 91       	ld	r18, X
     a22:	20 ff       	sbrs	r18, 0
     a24:	06 c0       	rjmp	.+12     	; 0xa32 <SRF05tinyFSM+0x240>
						{SensorModule[SensorNumber].Status.NewData=1;}					/* <Mark that unread value is available> */
     a26:	fc 01       	movw	r30, r24
     a28:	ea 51       	subi	r30, 0x1A	; 26
     a2a:	ff 4d       	sbci	r31, 0xDF	; 223
     a2c:	80 81       	ld	r24, Z
     a2e:	88 60       	ori	r24, 0x08	; 8
     a30:	80 83       	st	Z, r24
				}																		/* <Determine next state: idle until next communication cycle> */
				SensorNumber++;															/* <Leave this sensor and check the next> */
     a32:	d3 94       	inc	r13
				TWIWatchdogTimer = 0;													/* <Reset I2C WatchdogTimer> */
     a34:	10 92 39 20 	sts	0x2039, r1
     a38:	10 92 3a 20 	sts	0x203A, r1
     a3c:	01 c0       	rjmp	.+2      	; 0xa40 <SRF05tinyFSM+0x24e>
		break;
//-------------------------------------------------------------------------------------------------------
		case IdleState:
		case IdleState1:
		case ReviveState:
		SensorNumber++;
     a3e:	d3 94       	inc	r13
		break;
		default:
		break;
	}
	return SensorNumber;
}
     a40:	8d 2d       	mov	r24, r13
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	df 90       	pop	r13
     a50:	bf 90       	pop	r11
     a52:	af 90       	pop	r10
     a54:	08 95       	ret

00000a56 <CreateArraySameGroupIDs>:
 *
 *	Create an array with the IDs of sensors that belong in CurrentGroup (this group will begin measurements) 
 *	and clear 'Used' flag of Sensors in this group.
 */
void CreateArraySameGroupIDs(void)			
{
     a56:	aa ed       	ldi	r26, 0xDA	; 218
     a58:	b0 e2       	ldi	r27, 0x20	; 32
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i=0;
     a5e:	e0 e0       	ldi	r30, 0x00	; 0
	for(uint8_t k=0;k<I2CSENSNUM;k++)
	{
		if(SensorModule[k].Groupmember == CurrentGroup)
		{
			SameGroupIDs[i++] = k;
			SameGroupIDs[i] = 255;
     a60:	4f ef       	ldi	r20, 0xFF	; 255
			SensorModule[k].Status.Used = 0;
     a62:	5f e1       	ldi	r21, 0x1F	; 31
void CreateArraySameGroupIDs(void)			
{
	uint8_t i=0;
	for(uint8_t k=0;k<I2CSENSNUM;k++)
	{
		if(SensorModule[k].Groupmember == CurrentGroup)
     a64:	20 91 38 20 	lds	r18, 0x2038
     a68:	3c 91       	ld	r19, X
     a6a:	32 13       	cpse	r19, r18
     a6c:	16 c0       	rjmp	.+44     	; 0xa9a <CreateArraySameGroupIDs+0x44>
		{
			SameGroupIDs[i++] = k;
     a6e:	21 e0       	ldi	r18, 0x01	; 1
     a70:	2e 0f       	add	r18, r30
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	e3 5c       	subi	r30, 0xC3	; 195
     a76:	ff 4d       	sbci	r31, 0xDF	; 223
     a78:	80 83       	st	Z, r24
			SameGroupIDs[i] = 255;
     a7a:	e2 2f       	mov	r30, r18
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	e3 5c       	subi	r30, 0xC3	; 195
     a80:	ff 4d       	sbci	r31, 0xDF	; 223
     a82:	40 83       	st	Z, r20
			SensorModule[k].Status.Used = 0;
     a84:	58 9f       	mul	r21, r24
     a86:	f0 01       	movw	r30, r0
     a88:	59 9f       	mul	r21, r25
     a8a:	f0 0d       	add	r31, r0
     a8c:	11 24       	eor	r1, r1
     a8e:	ea 51       	subi	r30, 0x1A	; 26
     a90:	ff 4d       	sbci	r31, 0xDF	; 223
     a92:	30 81       	ld	r19, Z
     a94:	3e 7f       	andi	r19, 0xFE	; 254
     a96:	30 83       	st	Z, r19
	uint8_t i=0;
	for(uint8_t k=0;k<I2CSENSNUM;k++)
	{
		if(SensorModule[k].Groupmember == CurrentGroup)
		{
			SameGroupIDs[i++] = k;
     a98:	e2 2f       	mov	r30, r18
     a9a:	01 96       	adiw	r24, 0x01	; 1
     a9c:	5f 96       	adiw	r26, 0x1f	; 31
 *	and clear 'Used' flag of Sensors in this group.
 */
void CreateArraySameGroupIDs(void)			
{
	uint8_t i=0;
	for(uint8_t k=0;k<I2CSENSNUM;k++)
     a9e:	85 30       	cpi	r24, 0x05	; 5
     aa0:	91 05       	cpc	r25, r1
     aa2:	01 f7       	brne	.-64     	; 0xa64 <CreateArraySameGroupIDs+0xe>
			SameGroupIDs[i++] = k;
			SameGroupIDs[i] = 255;
			SensorModule[k].Status.Used = 0;
		}
	}	
}
     aa4:	08 95       	ret

00000aa6 <GroupHandler>:
 *	Check if all sensors in "CurrentGroup" ended measuring or are in revive state. 
 *	If true, initialize next group to be serviced.
 */
void GroupHandler(void)					
{
	uint8_t NextGroup = CurrentGroup+1;
     aa6:	20 91 38 20 	lds	r18, 0x2038
     aaa:	2f 5f       	subi	r18, 0xFF	; 255
	if (NextGroup > SENSORGROUPS){NextGroup=1;}
     aac:	24 30       	cpi	r18, 0x04	; 4
     aae:	08 f0       	brcs	.+2      	; 0xab2 <GroupHandler+0xc>
     ab0:	21 e0       	ldi	r18, 0x01	; 1


	uint8_t i=0;
     ab2:	30 e0       	ldi	r19, 0x00	; 0
	while(!(SameGroupIDs[i]==255))
	{
		WDT_Reset();
		if(!((SensorModule[SameGroupIDs[i]].CurrentState==FirstRunState)&&(SensorModule[SameGroupIDs[i]].Status.Used)))
     ab4:	5f e1       	ldi	r21, 0x1F	; 31
	uint8_t NextGroup = CurrentGroup+1;
	if (NextGroup > SENSORGROUPS){NextGroup=1;}


	uint8_t i=0;
	while(!(SameGroupIDs[i]==255))
     ab6:	e3 2f       	mov	r30, r19
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	e3 5c       	subi	r30, 0xC3	; 195
     abc:	ff 4d       	sbci	r31, 0xDF	; 223
     abe:	80 81       	ld	r24, Z
     ac0:	8f 3f       	cpi	r24, 0xFF	; 255
     ac2:	c1 f0       	breq	.+48     	; 0xaf4 <GroupHandler+0x4e>
	{
		WDT_Reset();
     ac4:	a8 95       	wdr
		if(!((SensorModule[SameGroupIDs[i]].CurrentState==FirstRunState)&&(SensorModule[SameGroupIDs[i]].Status.Used)))
     ac6:	58 9f       	mul	r21, r24
     ac8:	c0 01       	movw	r24, r0
     aca:	11 24       	eor	r1, r1
     acc:	fc 01       	movw	r30, r24
     ace:	e9 52       	subi	r30, 0x29	; 41
     ad0:	ff 4d       	sbci	r31, 0xDF	; 223
     ad2:	45 85       	ldd	r20, Z+13	; 0x0d
     ad4:	41 30       	cpi	r20, 0x01	; 1
     ad6:	39 f4       	brne	.+14     	; 0xae6 <GroupHandler+0x40>
     ad8:	fc 01       	movw	r30, r24
     ada:	ea 51       	subi	r30, 0x1A	; 26
     adc:	ff 4d       	sbci	r31, 0xDF	; 223
     ade:	80 81       	ld	r24, Z
     ae0:	80 fd       	sbrc	r24, 0
     ae2:	06 c0       	rjmp	.+12     	; 0xaf0 <GroupHandler+0x4a>
     ae4:	02 c0       	rjmp	.+4      	; 0xaea <GroupHandler+0x44>
		{
			if(!(SensorModule[SameGroupIDs[i]].CurrentState==ReviveState))
     ae6:	44 23       	and	r20, r20
     ae8:	19 f0       	breq	.+6      	; 0xaf0 <GroupHandler+0x4a>
			{
				NextGroup = CurrentGroup;
     aea:	20 91 38 20 	lds	r18, 0x2038
				break;
     aee:	02 c0       	rjmp	.+4      	; 0xaf4 <GroupHandler+0x4e>
			}
		}
		i++;
     af0:	3f 5f       	subi	r19, 0xFF	; 255
     af2:	e1 cf       	rjmp	.-62     	; 0xab6 <GroupHandler+0x10>
	}
	if (!(NextGroup==CurrentGroup))
     af4:	80 91 38 20 	lds	r24, 0x2038
     af8:	28 17       	cp	r18, r24
     afa:	21 f0       	breq	.+8      	; 0xb04 <GroupHandler+0x5e>
	{
		CurrentGroup=NextGroup;
     afc:	20 93 38 20 	sts	0x2038, r18
		CreateArraySameGroupIDs();
     b00:	0c 94 2b 05 	jmp	0xa56	; 0xa56 <CreateArraySameGroupIDs>
     b04:	08 95       	ret

00000b06 <FindFirstAvailableSensor>:
/*!< Brief function description
 *
 *	Select next available sensor to be serviced on I2C bus.
 */
uint8_t FindFirstAvailableSensor(uint8_t SensorNumber)
{
     b06:	cf 93       	push	r28
     b08:	df 93       	push	r29
     b0a:	b8 2f       	mov	r27, r24
	uint8_t i=SensorNumber;
	uint8_t k=i;
	for(uint8_t j=i;j<(i+I2CSENSNUM);j++){
     b0c:	a8 2f       	mov	r26, r24
     b0e:	28 2f       	mov	r18, r24
     b10:	30 e0       	ldi	r19, 0x00	; 0
     b12:	2c 5f       	subi	r18, 0xFC	; 252
     b14:	3f 4f       	sbci	r19, 0xFF	; 255
		if(!(SensorModule[j%I2CSENSNUM].CurrentState==ReviveState)){
     b16:	c5 e0       	ldi	r28, 0x05	; 5
     b18:	df e1       	ldi	r29, 0x1F	; 31
 */
uint8_t FindFirstAvailableSensor(uint8_t SensorNumber)
{
	uint8_t i=SensorNumber;
	uint8_t k=i;
	for(uint8_t j=i;j<(i+I2CSENSNUM);j++){
     b1a:	4a 2f       	mov	r20, r26
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	24 17       	cp	r18, r20
     b20:	35 07       	cpc	r19, r21
     b22:	14 f1       	brlt	.+68     	; 0xb68 <FindFirstAvailableSensor+0x62>
		if(!(SensorModule[j%I2CSENSNUM].CurrentState==ReviveState)){
     b24:	8a 2f       	mov	r24, r26
     b26:	6c 2f       	mov	r22, r28
     b28:	0e 94 18 0c 	call	0x1830	; 0x1830 <__udivmodqi4>
     b2c:	89 2f       	mov	r24, r25
     b2e:	d9 9f       	mul	r29, r25
     b30:	a0 01       	movw	r20, r0
     b32:	11 24       	eor	r1, r1
     b34:	fa 01       	movw	r30, r20
     b36:	e9 52       	subi	r30, 0x29	; 41
     b38:	ff 4d       	sbci	r31, 0xDF	; 223
     b3a:	95 85       	ldd	r25, Z+13	; 0x0d
     b3c:	69 2f       	mov	r22, r25
     b3e:	67 7f       	andi	r22, 0xF7	; 247
     b40:	89 f0       	breq	.+34     	; 0xb64 <FindFirstAvailableSensor+0x5e>
			if(!(SensorModule[j%I2CSENSNUM].CurrentState==IdleState)){
				if(!(SensorModule[j%I2CSENSNUM].CurrentState==IdleState1)){
     b42:	96 30       	cpi	r25, 0x06	; 6
     b44:	79 f0       	breq	.+30     	; 0xb64 <FindFirstAvailableSensor+0x5e>
						if((SensorModule[j%I2CSENSNUM].Groupmember==0))
     b46:	73 81       	ldd	r23, Z+3	; 0x03
     b48:	77 23       	and	r23, r23
     b4a:	79 f0       	breq	.+30     	; 0xb6a <FindFirstAvailableSensor+0x64>
						{k=j%I2CSENSNUM;
						break;}
					else
					{if(SensorModule[j%I2CSENSNUM].Groupmember==CurrentGroup){
     b4c:	60 91 38 20 	lds	r22, 0x2038
     b50:	76 13       	cpse	r23, r22
     b52:	08 c0       	rjmp	.+16     	; 0xb64 <FindFirstAvailableSensor+0x5e>
						if(!((SensorModule[j%I2CSENSNUM].CurrentState==FirstRunState)&&(SensorModule[j%I2CSENSNUM].Status.Used)))
     b54:	91 30       	cpi	r25, 0x01	; 1
     b56:	49 f4       	brne	.+18     	; 0xb6a <FindFirstAvailableSensor+0x64>
     b58:	fa 01       	movw	r30, r20
     b5a:	ea 51       	subi	r30, 0x1A	; 26
     b5c:	ff 4d       	sbci	r31, 0xDF	; 223
     b5e:	90 81       	ld	r25, Z
     b60:	90 ff       	sbrs	r25, 0
     b62:	03 c0       	rjmp	.+6      	; 0xb6a <FindFirstAvailableSensor+0x64>
 */
uint8_t FindFirstAvailableSensor(uint8_t SensorNumber)
{
	uint8_t i=SensorNumber;
	uint8_t k=i;
	for(uint8_t j=i;j<(i+I2CSENSNUM);j++){
     b64:	af 5f       	subi	r26, 0xFF	; 255
     b66:	d9 cf       	rjmp	.-78     	; 0xb1a <FindFirstAvailableSensor+0x14>
 *	Select next available sensor to be serviced on I2C bus.
 */
uint8_t FindFirstAvailableSensor(uint8_t SensorNumber)
{
	uint8_t i=SensorNumber;
	uint8_t k=i;
     b68:	8b 2f       	mov	r24, r27
				}
			}	
		}	
	}
	return	i=k;
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	08 95       	ret

00000b70 <I2CSensorFSMCore>:
 *
 *	FSM core for I2C communications.
 *	Lasts 15usec MAX.
 */
uint8_t I2CSensorFSMCore(uint8_t SensorNumber)
{
     b70:	cf 93       	push	r28
     b72:	c8 2f       	mov	r28, r24
	uint8_t NextSensorID=SensorNumber;
	if(!((PCTXFlags&PCTX_DebugMode)&&(PCTXFlags&PCTX_Busy)))
     b74:	80 91 c0 20 	lds	r24, 0x20C0
     b78:	82 ff       	sbrs	r24, 2
     b7a:	04 c0       	rjmp	.+8      	; 0xb84 <I2CSensorFSMCore+0x14>
     b7c:	80 91 c0 20 	lds	r24, 0x20C0
     b80:	80 fd       	sbrc	r24, 0
     b82:	0f c0       	rjmp	.+30     	; 0xba2 <I2CSensorFSMCore+0x32>
	{
 		uint8_t CurrentSensorID=FindFirstAvailableSensor(SensorNumber);
     b84:	8c 2f       	mov	r24, r28
     b86:	0e 94 83 05 	call	0xb06	; 0xb06 <FindFirstAvailableSensor>
		
		switch (SensorModule[CurrentSensorID].type)
     b8a:	9f e1       	ldi	r25, 0x1F	; 31
     b8c:	89 9f       	mul	r24, r25
     b8e:	f0 01       	movw	r30, r0
     b90:	11 24       	eor	r1, r1
     b92:	e9 52       	subi	r30, 0x29	; 41
     b94:	ff 4d       	sbci	r31, 0xDF	; 223
     b96:	90 81       	ld	r25, Z
     b98:	91 11       	cpse	r25, r1
     b9a:	03 c0       	rjmp	.+6      	; 0xba2 <I2CSensorFSMCore+0x32>
		{
			case SRF05tinym:
				NextSensorID=SRF05tinyFSM(CurrentSensorID);
     b9c:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <SRF05tinyFSM>
     ba0:	c8 2f       	mov	r28, r24
			break;
			default:
			break;
		}	
	}
	NextSensorID=(NextSensorID % I2CSENSNUM);
     ba2:	8c 2f       	mov	r24, r28
     ba4:	65 e0       	ldi	r22, 0x05	; 5
     ba6:	0e 94 18 0c 	call	0x1830	; 0x1830 <__udivmodqi4>
     baa:	89 2f       	mov	r24, r25
	return NextSensorID;
}
     bac:	cf 91       	pop	r28
     bae:	08 95       	ret

00000bb0 <data_transmitService>:
uint8_t *PCTXBuffer;
uint16_t	PCTXWaitAckNakTimer;

void data_transmitService(void)
{
	if( (PCTXFlags & PCTX_Busy) && !(PCTXFlags & PCTX_WaitAckNaK) )
     bb0:	80 91 c0 20 	lds	r24, 0x20C0
     bb4:	80 ff       	sbrs	r24, 0
     bb6:	5b c0       	rjmp	.+182    	; 0xc6e <data_transmitService+0xbe>
     bb8:	80 91 c0 20 	lds	r24, 0x20C0
     bbc:	81 fd       	sbrc	r24, 1
     bbe:	57 c0       	rjmp	.+174    	; 0xc6e <data_transmitService+0xbe>
	{
		PCTXPointer++;
     bc0:	80 91 c5 20 	lds	r24, 0x20C5
     bc4:	90 91 c6 20 	lds	r25, 0x20C6
     bc8:	01 96       	adiw	r24, 0x01	; 1
     bca:	80 93 c5 20 	sts	0x20C5, r24
     bce:	90 93 c6 20 	sts	0x20C6, r25
		if(PCTXPointer<PCTXBufferLen && (USARTD0.STATUS & USART_DREIF_bm))
     bd2:	20 91 c5 20 	lds	r18, 0x20C5
     bd6:	30 91 c6 20 	lds	r19, 0x20C6
     bda:	80 91 c7 20 	lds	r24, 0x20C7
     bde:	90 91 c8 20 	lds	r25, 0x20C8
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	88 f4       	brcc	.+34     	; 0xc0a <data_transmitService+0x5a>
     be8:	80 91 a1 09 	lds	r24, 0x09A1
     bec:	85 ff       	sbrs	r24, 5
     bee:	0d c0       	rjmp	.+26     	; 0xc0a <data_transmitService+0x5a>
		{
			usart_putc(PCTXBuffer[PCTXPointer]);
     bf0:	80 91 c5 20 	lds	r24, 0x20C5
     bf4:	90 91 c6 20 	lds	r25, 0x20C6
     bf8:	e0 91 c3 20 	lds	r30, 0x20C3
     bfc:	f0 91 c4 20 	lds	r31, 0x20C4
     c00:	e8 0f       	add	r30, r24
     c02:	f9 1f       	adc	r31, r25
     c04:	80 81       	ld	r24, Z
     c06:	0e 94 6f 02 	call	0x4de	; 0x4de <usart_putc>
		}
		PCTXPointer %= PCTXBufferLen;								/* <keep PCTXPointer in range [0,PCTXBufferLen]> */
     c0a:	80 91 c5 20 	lds	r24, 0x20C5
     c0e:	90 91 c6 20 	lds	r25, 0x20C6
     c12:	60 91 c7 20 	lds	r22, 0x20C7
     c16:	70 91 c8 20 	lds	r23, 0x20C8
     c1a:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
     c1e:	80 93 c5 20 	sts	0x20C5, r24
     c22:	90 93 c6 20 	sts	0x20C6, r25
		if(!PCTXPointer)
     c26:	80 91 c5 20 	lds	r24, 0x20C5
     c2a:	90 91 c6 20 	lds	r25, 0x20C6
     c2e:	89 2b       	or	r24, r25
     c30:	f1 f4       	brne	.+60     	; 0xc6e <data_transmitService+0xbe>
		{
			/* <Clear PCTX_Busy when all data have been transfered> */
			PCTXFlags &= ~(PCTX_Busy);
     c32:	80 91 c0 20 	lds	r24, 0x20C0
     c36:	8e 7f       	andi	r24, 0xFE	; 254
     c38:	80 93 c0 20 	sts	0x20C0, r24
			if( !(PCTXFlags&PCTX_DebugMode) )
     c3c:	80 91 c0 20 	lds	r24, 0x20C0
     c40:	82 fd       	sbrc	r24, 2
     c42:	0b c0       	rjmp	.+22     	; 0xc5a <data_transmitService+0xaa>
			{
				PCTXFlags |= (PCTX_WaitAckNaK|PCTX_Busy);			/* <Set WaitAckNak and Busy Flags for UART> */
     c44:	80 91 c0 20 	lds	r24, 0x20C0
     c48:	83 60       	ori	r24, 0x03	; 3
     c4a:	80 93 c0 20 	sts	0x20C0, r24
				PCTXWaitAckNakTimer = WaitAckNakTimeOut;
     c4e:	80 e1       	ldi	r24, 0x10	; 16
     c50:	97 e2       	ldi	r25, 0x27	; 39
     c52:	80 93 c1 20 	sts	0x20C1, r24
     c56:	90 93 c2 20 	sts	0x20C2, r25
			}
			USARTD0.STATUS |= USART_DREIF_bm;
     c5a:	80 91 a1 09 	lds	r24, 0x09A1
     c5e:	80 62       	ori	r24, 0x20	; 32
     c60:	80 93 a1 09 	sts	0x09A1, r24
			USARTD0.STATUS |= USART_RXCIF_bm;						/* <CLEAR RECEIVED DATA FLAG IN USART> */
     c64:	80 91 a1 09 	lds	r24, 0x09A1
     c68:	80 68       	ori	r24, 0x80	; 128
     c6a:	80 93 a1 09 	sts	0x09A1, r24
		}
	}
	if( (PCTXFlags&PCTX_Busy)&&(PCTXFlags&PCTX_WaitAckNaK) )
     c6e:	80 91 c0 20 	lds	r24, 0x20C0
     c72:	80 ff       	sbrs	r24, 0
     c74:	28 c0       	rjmp	.+80     	; 0xcc6 <data_transmitService+0x116>
     c76:	80 91 c0 20 	lds	r24, 0x20C0
     c7a:	81 ff       	sbrs	r24, 1
     c7c:	24 c0       	rjmp	.+72     	; 0xcc6 <data_transmitService+0x116>
	{
		if(PCTXWaitAckNakTimer)
     c7e:	80 91 c1 20 	lds	r24, 0x20C1
     c82:	90 91 c2 20 	lds	r25, 0x20C2
     c86:	89 2b       	or	r24, r25
     c88:	c9 f0       	breq	.+50     	; 0xcbc <data_transmitService+0x10c>
		{
			if(USARTD0.STATUS & USART_RXCIF_bm)
     c8a:	80 91 a1 09 	lds	r24, 0x09A1
     c8e:	87 ff       	sbrs	r24, 7
     c90:	1a c0       	rjmp	.+52     	; 0xcc6 <data_transmitService+0x116>
			{
				uint8_t	TempReceive=USARTD0.DATA;
     c92:	90 91 a0 09 	lds	r25, 0x09A0
				USARTD0.STATUS |=USART_RXCIF_bm;
     c96:	80 91 a1 09 	lds	r24, 0x09A1
     c9a:	80 68       	ori	r24, 0x80	; 128
     c9c:	80 93 a1 09 	sts	0x09A1, r24
				if (TempReceive == UACK)
				{
					/* <Last packet transmission was successful. Close the service> */
					PCTXFlags &= ~(PCTX_Busy|PCTX_WaitAckNaK);		
     ca0:	80 91 c0 20 	lds	r24, 0x20C0
		{
			if(USARTD0.STATUS & USART_RXCIF_bm)
			{
				uint8_t	TempReceive=USARTD0.DATA;
				USARTD0.STATUS |=USART_RXCIF_bm;
				if (TempReceive == UACK)
     ca4:	96 30       	cpi	r25, 0x06	; 6
     ca6:	61 f0       	breq	.+24     	; 0xcc0 <data_transmitService+0x110>
					PCTXFlags &= ~(PCTX_Busy|PCTX_WaitAckNaK);		
				}
				else
				{
					/* <Repeat last transmission!!> */
					PCTXFlags &= ~PCTX_WaitAckNaK;					
     ca8:	8d 7f       	andi	r24, 0xFD	; 253
     caa:	80 93 c0 20 	sts	0x20C0, r24
					usart_putc(PCTXBuffer[0]);
     cae:	e0 91 c3 20 	lds	r30, 0x20C3
     cb2:	f0 91 c4 20 	lds	r31, 0x20C4
     cb6:	80 81       	ld	r24, Z
     cb8:	0c 94 6f 02 	jmp	0x4de	; 0x4de <usart_putc>
			}
		}
		else
		{
			/* <Last packet transmission was without response from PC. Close the service and try again with new data> */
			PCTXFlags &= ~(PCTX_Busy|PCTX_WaitAckNaK);				
     cbc:	80 91 c0 20 	lds	r24, 0x20C0
     cc0:	8c 7f       	andi	r24, 0xFC	; 252
     cc2:	80 93 c0 20 	sts	0x20C0, r24
     cc6:	08 95       	ret

00000cc8 <PutSensorSeparatorInPCTXBuffer>:
 *	Insert, between sensors, seperator character (LF = 0x0A)
*/
uint16_t PutSensorSeparatorInPCTXBuffer(uint16_t PCTXCurrentPointer)
{
	uint16_t RealPCTXBufferPointer = PCTXCurrentPointer;
	PCTXBuffer[RealPCTXBufferPointer++]=LF;	//=RS
     cc8:	e0 91 c3 20 	lds	r30, 0x20C3
     ccc:	f0 91 c4 20 	lds	r31, 0x20C4
     cd0:	e8 0f       	add	r30, r24
     cd2:	f9 1f       	adc	r31, r25
     cd4:	2a e0       	ldi	r18, 0x0A	; 10
     cd6:	20 83       	st	Z, r18
	return RealPCTXBufferPointer;
}
     cd8:	01 96       	adiw	r24, 0x01	; 1
     cda:	08 95       	ret

00000cdc <copyBatteriesInfo_PCTXBuffer>:
 *	Header = BatterySensorID (3 bytes) + BatterySensorType (3 bytes).
 *	Value = BatteryMotor (3bytes) + BatteryPSU (3 bytes).
 *	LineFeed = LF character (0x0A).
*/ 
uint16_t copyBatteriesInfo_PCTXBuffer(uint16_t PCTXCurrentPointer)
{
     cdc:	cf 93       	push	r28
     cde:	df 93       	push	r29
	uint16_t pctxCurrentPointer_ = PCTXCurrentPointer;
	
	/* <battery "sensor" ID> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((I2CSENSNUM)&0xf0)>>4];
     ce0:	e0 91 c3 20 	lds	r30, 0x20C3
     ce4:	f0 91 c4 20 	lds	r31, 0x20C4
     ce8:	e8 0f       	add	r30, r24
     cea:	f9 1f       	adc	r31, r25
     cec:	30 e3       	ldi	r19, 0x30	; 48
     cee:	30 83       	st	Z, r19
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((I2CSENSNUM)&0x0f)];
     cf0:	e0 91 c3 20 	lds	r30, 0x20C3
     cf4:	f0 91 c4 20 	lds	r31, 0x20C4
     cf8:	e8 0f       	add	r30, r24
     cfa:	f9 1f       	adc	r31, r25
     cfc:	25 e3       	ldi	r18, 0x35	; 53
     cfe:	21 83       	std	Z+1, r18	; 0x01
	PCTXBuffer[pctxCurrentPointer_++] = ' ';
     d00:	e0 91 c3 20 	lds	r30, 0x20C3
     d04:	f0 91 c4 20 	lds	r31, 0x20C4
     d08:	e8 0f       	add	r30, r24
     d0a:	f9 1f       	adc	r31, r25
     d0c:	20 e2       	ldi	r18, 0x20	; 32
     d0e:	22 83       	std	Z+2, r18	; 0x02
	/* <battery "sensor" TYPE> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((Battery)&0xf0)>>4];
     d10:	e0 91 c3 20 	lds	r30, 0x20C3
     d14:	f0 91 c4 20 	lds	r31, 0x20C4
     d18:	e8 0f       	add	r30, r24
     d1a:	f9 1f       	adc	r31, r25
     d1c:	33 83       	std	Z+3, r19	; 0x03
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((Battery)&0x0f)];
     d1e:	e0 91 c3 20 	lds	r30, 0x20C3
     d22:	f0 91 c4 20 	lds	r31, 0x20C4
     d26:	e8 0f       	add	r30, r24
     d28:	f9 1f       	adc	r31, r25
     d2a:	31 e3       	ldi	r19, 0x31	; 49
     d2c:	34 83       	std	Z+4, r19	; 0x04
	PCTXBuffer[pctxCurrentPointer_++] = ' ';
     d2e:	e0 91 c3 20 	lds	r30, 0x20C3
     d32:	f0 91 c4 20 	lds	r31, 0x20C4
     d36:	e8 0f       	add	r30, r24
     d38:	f9 1f       	adc	r31, r25
     d3a:	25 83       	std	Z+5, r18	; 0x05
	/* <battery has no status. Data comes next!!> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_PSU&0x0f00)>>8];
     d3c:	e0 91 c3 20 	lds	r30, 0x20C3
     d40:	f0 91 c4 20 	lds	r31, 0x20C4
     d44:	e8 0f       	add	r30, r24
     d46:	f9 1f       	adc	r31, r25
     d48:	c3 ed       	ldi	r28, 0xD3	; 211
     d4a:	d0 e2       	ldi	r29, 0x20	; 32
     d4c:	a8 81       	ld	r26, Y
     d4e:	b9 81       	ldd	r27, Y+1	; 0x01
     d50:	aa 27       	eor	r26, r26
     d52:	bf 70       	andi	r27, 0x0F	; 15
     d54:	ab 2f       	mov	r26, r27
     d56:	bb 27       	eor	r27, r27
     d58:	aa 5f       	subi	r26, 0xFA	; 250
     d5a:	bf 4d       	sbci	r27, 0xDF	; 223
     d5c:	2c 91       	ld	r18, X
     d5e:	26 83       	std	Z+6, r18	; 0x06
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_PSU&0x00f0)>>4];
     d60:	a0 91 c3 20 	lds	r26, 0x20C3
     d64:	b0 91 c4 20 	lds	r27, 0x20C4
     d68:	a8 0f       	add	r26, r24
     d6a:	b9 1f       	adc	r27, r25
     d6c:	e8 81       	ld	r30, Y
     d6e:	f9 81       	ldd	r31, Y+1	; 0x01
     d70:	e0 7f       	andi	r30, 0xF0	; 240
     d72:	ff 27       	eor	r31, r31
     d74:	34 e0       	ldi	r19, 0x04	; 4
     d76:	f6 95       	lsr	r31
     d78:	e7 95       	ror	r30
     d7a:	3a 95       	dec	r19
     d7c:	e1 f7       	brne	.-8      	; 0xd76 <copyBatteriesInfo_PCTXBuffer+0x9a>
     d7e:	ea 5f       	subi	r30, 0xFA	; 250
     d80:	ff 4d       	sbci	r31, 0xDF	; 223
     d82:	20 81       	ld	r18, Z
     d84:	17 96       	adiw	r26, 0x07	; 7
     d86:	2c 93       	st	X, r18
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_PSU&0x000f)];
     d88:	a0 91 c3 20 	lds	r26, 0x20C3
     d8c:	b0 91 c4 20 	lds	r27, 0x20C4
     d90:	a8 0f       	add	r26, r24
     d92:	b9 1f       	adc	r27, r25
     d94:	e8 81       	ld	r30, Y
     d96:	f9 81       	ldd	r31, Y+1	; 0x01
     d98:	ef 70       	andi	r30, 0x0F	; 15
     d9a:	ff 27       	eor	r31, r31
     d9c:	ea 5f       	subi	r30, 0xFA	; 250
     d9e:	ff 4d       	sbci	r31, 0xDF	; 223
     da0:	20 81       	ld	r18, Z
     da2:	18 96       	adiw	r26, 0x08	; 8
     da4:	2c 93       	st	X, r18
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x0f00)>>8];
     da6:	e0 91 c3 20 	lds	r30, 0x20C3
     daa:	f0 91 c4 20 	lds	r31, 0x20C4
     dae:	e8 0f       	add	r30, r24
     db0:	f9 1f       	adc	r31, r25
     db2:	c5 ed       	ldi	r28, 0xD5	; 213
     db4:	d0 e2       	ldi	r29, 0x20	; 32
     db6:	a8 81       	ld	r26, Y
     db8:	b9 81       	ldd	r27, Y+1	; 0x01
     dba:	aa 27       	eor	r26, r26
     dbc:	bf 70       	andi	r27, 0x0F	; 15
     dbe:	ab 2f       	mov	r26, r27
     dc0:	bb 27       	eor	r27, r27
     dc2:	aa 5f       	subi	r26, 0xFA	; 250
     dc4:	bf 4d       	sbci	r27, 0xDF	; 223
     dc6:	2c 91       	ld	r18, X
     dc8:	21 87       	std	Z+9, r18	; 0x09
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x00f0)>>4];
     dca:	a0 91 c3 20 	lds	r26, 0x20C3
     dce:	b0 91 c4 20 	lds	r27, 0x20C4
     dd2:	a8 0f       	add	r26, r24
     dd4:	b9 1f       	adc	r27, r25
     dd6:	e8 81       	ld	r30, Y
     dd8:	f9 81       	ldd	r31, Y+1	; 0x01
     dda:	e0 7f       	andi	r30, 0xF0	; 240
     ddc:	ff 27       	eor	r31, r31
     dde:	54 e0       	ldi	r21, 0x04	; 4
     de0:	f6 95       	lsr	r31
     de2:	e7 95       	ror	r30
     de4:	5a 95       	dec	r21
     de6:	e1 f7       	brne	.-8      	; 0xde0 <copyBatteriesInfo_PCTXBuffer+0x104>
     de8:	ea 5f       	subi	r30, 0xFA	; 250
     dea:	ff 4d       	sbci	r31, 0xDF	; 223
     dec:	20 81       	ld	r18, Z
     dee:	1a 96       	adiw	r26, 0x0a	; 10
     df0:	2c 93       	st	X, r18
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x000f)];
     df2:	a0 91 c3 20 	lds	r26, 0x20C3
     df6:	b0 91 c4 20 	lds	r27, 0x20C4
     dfa:	a8 0f       	add	r26, r24
     dfc:	b9 1f       	adc	r27, r25
     dfe:	e8 81       	ld	r30, Y
     e00:	f9 81       	ldd	r31, Y+1	; 0x01
     e02:	ef 70       	andi	r30, 0x0F	; 15
     e04:	ff 27       	eor	r31, r31
     e06:	ea 5f       	subi	r30, 0xFA	; 250
     e08:	ff 4d       	sbci	r31, 0xDF	; 223
     e0a:	20 81       	ld	r18, Z
     e0c:	1b 96       	adiw	r26, 0x0b	; 11
     e0e:	2c 93       	st	X, r18
	pctxCurrentPointer_ = PutSensorSeparatorInPCTXBuffer(pctxCurrentPointer_);						/* <LF 1 Byte> */
     e10:	0c 96       	adiw	r24, 0x0c	; 12
	
	return (pctxCurrentPointer_);
}
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_PSU&0x00f0)>>4];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_PSU&0x000f)];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x0f00)>>8];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x00f0)>>4];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_batteries.batteryVoltage_MOTOR&0x000f)];
	pctxCurrentPointer_ = PutSensorSeparatorInPCTXBuffer(pctxCurrentPointer_);						/* <LF 1 Byte> */
     e16:	0c 94 64 06 	jmp	0xcc8	; 0xcc8 <PutSensorSeparatorInPCTXBuffer>

00000e1a <copyEncoderInfo_PCTXBuffer>:
 *	Header = EncoderSensorID (3 bytes) + EncoderSensorType (3 bytes).
 *	Value = Encoder (3bytes) (3*Nybble)
 *	LineFeed = LF character (0x0A).
*/ 
uint16_t copyEncoderInfo_PCTXBuffer(uint16_t PCTXCurrentPointer)
{
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
	uint16_t pctxCurrentPointer_ = PCTXCurrentPointer;
	
	/* <Encoder "sensor" ID> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((I2CSENSNUM+1)&0xf0)>>4];
     e1e:	e0 91 c3 20 	lds	r30, 0x20C3
     e22:	f0 91 c4 20 	lds	r31, 0x20C4
     e26:	e8 0f       	add	r30, r24
     e28:	f9 1f       	adc	r31, r25
     e2a:	30 e3       	ldi	r19, 0x30	; 48
     e2c:	30 83       	st	Z, r19
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((I2CSENSNUM+1)&0x0f)];
     e2e:	e0 91 c3 20 	lds	r30, 0x20C3
     e32:	f0 91 c4 20 	lds	r31, 0x20C4
     e36:	e8 0f       	add	r30, r24
     e38:	f9 1f       	adc	r31, r25
     e3a:	26 e3       	ldi	r18, 0x36	; 54
     e3c:	21 83       	std	Z+1, r18	; 0x01
	PCTXBuffer[pctxCurrentPointer_++] = ' ';
     e3e:	e0 91 c3 20 	lds	r30, 0x20C3
     e42:	f0 91 c4 20 	lds	r31, 0x20C4
     e46:	e8 0f       	add	r30, r24
     e48:	f9 1f       	adc	r31, r25
     e4a:	20 e2       	ldi	r18, 0x20	; 32
     e4c:	22 83       	std	Z+2, r18	; 0x02
	/* <Encoder "sensor" TYPE> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((RotaryEncoder)&0xf0)>>4];
     e4e:	e0 91 c3 20 	lds	r30, 0x20C3
     e52:	f0 91 c4 20 	lds	r31, 0x20C4
     e56:	e8 0f       	add	r30, r24
     e58:	f9 1f       	adc	r31, r25
     e5a:	33 83       	std	Z+3, r19	; 0x03
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[((RotaryEncoder)&0x0f)];
     e5c:	e0 91 c3 20 	lds	r30, 0x20C3
     e60:	f0 91 c4 20 	lds	r31, 0x20C4
     e64:	e8 0f       	add	r30, r24
     e66:	f9 1f       	adc	r31, r25
     e68:	32 e3       	ldi	r19, 0x32	; 50
     e6a:	34 83       	std	Z+4, r19	; 0x04
	PCTXBuffer[pctxCurrentPointer_++] = ' ';
     e6c:	e0 91 c3 20 	lds	r30, 0x20C3
     e70:	f0 91 c4 20 	lds	r31, 0x20C4
     e74:	e8 0f       	add	r30, r24
     e76:	f9 1f       	adc	r31, r25
     e78:	25 83       	std	Z+5, r18	; 0x05
	/* <Encoder data> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x0f00)>>8];
     e7a:	e0 91 c3 20 	lds	r30, 0x20C3
     e7e:	f0 91 c4 20 	lds	r31, 0x20C4
     e82:	e8 0f       	add	r30, r24
     e84:	f9 1f       	adc	r31, r25
     e86:	cd ec       	ldi	r28, 0xCD	; 205
     e88:	d0 e2       	ldi	r29, 0x20	; 32
     e8a:	a8 81       	ld	r26, Y
     e8c:	b9 81       	ldd	r27, Y+1	; 0x01
     e8e:	aa 27       	eor	r26, r26
     e90:	bf 70       	andi	r27, 0x0F	; 15
     e92:	ab 2f       	mov	r26, r27
     e94:	bb 27       	eor	r27, r27
     e96:	aa 5f       	subi	r26, 0xFA	; 250
     e98:	bf 4d       	sbci	r27, 0xDF	; 223
     e9a:	2c 91       	ld	r18, X
     e9c:	26 83       	std	Z+6, r18	; 0x06
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x00f0)>>4];
     e9e:	a0 91 c3 20 	lds	r26, 0x20C3
     ea2:	b0 91 c4 20 	lds	r27, 0x20C4
     ea6:	a8 0f       	add	r26, r24
     ea8:	b9 1f       	adc	r27, r25
     eaa:	e8 81       	ld	r30, Y
     eac:	f9 81       	ldd	r31, Y+1	; 0x01
     eae:	e0 7f       	andi	r30, 0xF0	; 240
     eb0:	ff 27       	eor	r31, r31
     eb2:	74 e0       	ldi	r23, 0x04	; 4
     eb4:	f6 95       	lsr	r31
     eb6:	e7 95       	ror	r30
     eb8:	7a 95       	dec	r23
     eba:	e1 f7       	brne	.-8      	; 0xeb4 <copyEncoderInfo_PCTXBuffer+0x9a>
     ebc:	ea 5f       	subi	r30, 0xFA	; 250
     ebe:	ff 4d       	sbci	r31, 0xDF	; 223
     ec0:	20 81       	ld	r18, Z
     ec2:	17 96       	adiw	r26, 0x07	; 7
     ec4:	2c 93       	st	X, r18
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x000f)];
     ec6:	a0 91 c3 20 	lds	r26, 0x20C3
     eca:	b0 91 c4 20 	lds	r27, 0x20C4
     ece:	a8 0f       	add	r26, r24
     ed0:	b9 1f       	adc	r27, r25
     ed2:	e8 81       	ld	r30, Y
     ed4:	f9 81       	ldd	r31, Y+1	; 0x01
     ed6:	ef 70       	andi	r30, 0x0F	; 15
     ed8:	ff 27       	eor	r31, r31
     eda:	ea 5f       	subi	r30, 0xFA	; 250
     edc:	ff 4d       	sbci	r31, 0xDF	; 223
     ede:	20 81       	ld	r18, Z
     ee0:	18 96       	adiw	r26, 0x08	; 8
     ee2:	2c 93       	st	X, r18
	/* <LF 1 Byte> */
	pctxCurrentPointer_ = PutSensorSeparatorInPCTXBuffer(pctxCurrentPointer_);						
     ee4:	09 96       	adiw	r24, 0x09	; 9
	
	return (pctxCurrentPointer_);
}
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
	/* <Encoder data> */
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x0f00)>>8];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x00f0)>>4];
	PCTXBuffer[pctxCurrentPointer_++] = nybble_chars[(_encoder.encoder_value_degrees&0x000f)];
	/* <LF 1 Byte> */
	pctxCurrentPointer_ = PutSensorSeparatorInPCTXBuffer(pctxCurrentPointer_);						
     eea:	0c 94 64 06 	jmp	0xcc8	; 0xcc8 <PutSensorSeparatorInPCTXBuffer>

00000eee <CopySensorHeaderToPCTXBuffer>:
 *
 *	Copy I2C sensors Header in PCTX Buffer
 *	Header length (bytes) = 15
*/
uint16_t CopySensorHeaderToPCTXBuffer(uint8_t SensorNumber, uint16_t PCTXCurrentPointer)
{
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
	uint16_t RealPCTXBufferPointer = PCTXCurrentPointer;
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].SensorID>>4) & 0x0f];		/* <High Nibble of SensorID in ASCII> */
     ef2:	a0 91 c3 20 	lds	r26, 0x20C3
     ef6:	b0 91 c4 20 	lds	r27, 0x20C4
     efa:	a6 0f       	add	r26, r22
     efc:	b7 1f       	adc	r27, r23
     efe:	9f e1       	ldi	r25, 0x1F	; 31
     f00:	89 9f       	mul	r24, r25
     f02:	f0 01       	movw	r30, r0
     f04:	11 24       	eor	r1, r1
     f06:	e9 52       	subi	r30, 0x29	; 41
     f08:	ff 4d       	sbci	r31, 0xDF	; 223
     f0a:	c1 81       	ldd	r28, Z+1	; 0x01
     f0c:	c2 95       	swap	r28
     f0e:	cf 70       	andi	r28, 0x0F	; 15
     f10:	d0 e0       	ldi	r29, 0x00	; 0
     f12:	ca 5f       	subi	r28, 0xFA	; 250
     f14:	df 4d       	sbci	r29, 0xDF	; 223
     f16:	88 81       	ld	r24, Y
     f18:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].SensorID) & 0x0f];			/* <Lo Nibble of SensorID in ASCII> */
     f1a:	a0 91 c3 20 	lds	r26, 0x20C3
     f1e:	b0 91 c4 20 	lds	r27, 0x20C4
     f22:	a6 0f       	add	r26, r22
     f24:	b7 1f       	adc	r27, r23
     f26:	c1 81       	ldd	r28, Z+1	; 0x01
     f28:	cf 70       	andi	r28, 0x0F	; 15
     f2a:	d0 e0       	ldi	r29, 0x00	; 0
     f2c:	ca 5f       	subi	r28, 0xFA	; 250
     f2e:	df 4d       	sbci	r29, 0xDF	; 223
     f30:	88 81       	ld	r24, Y
     f32:	11 96       	adiw	r26, 0x01	; 1
     f34:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=' ';
     f36:	a0 91 c3 20 	lds	r26, 0x20C3
     f3a:	b0 91 c4 20 	lds	r27, 0x20C4
     f3e:	a6 0f       	add	r26, r22
     f40:	b7 1f       	adc	r27, r23
     f42:	80 e2       	ldi	r24, 0x20	; 32
     f44:	12 96       	adiw	r26, 0x02	; 2
     f46:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].type>>4) & 0x0f];			/* <High Nibble of SensorType in ASCII> */
     f48:	a0 91 c3 20 	lds	r26, 0x20C3
     f4c:	b0 91 c4 20 	lds	r27, 0x20C4
     f50:	a6 0f       	add	r26, r22
     f52:	b7 1f       	adc	r27, r23
     f54:	c0 81       	ld	r28, Z
     f56:	c2 95       	swap	r28
     f58:	cf 70       	andi	r28, 0x0F	; 15
     f5a:	d0 e0       	ldi	r29, 0x00	; 0
     f5c:	ca 5f       	subi	r28, 0xFA	; 250
     f5e:	df 4d       	sbci	r29, 0xDF	; 223
     f60:	98 81       	ld	r25, Y
     f62:	13 96       	adiw	r26, 0x03	; 3
     f64:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].type) & 0x0f];				/* <Lo Nibble of SensorType in ASCII> */
     f66:	a0 91 c3 20 	lds	r26, 0x20C3
     f6a:	b0 91 c4 20 	lds	r27, 0x20C4
     f6e:	a6 0f       	add	r26, r22
     f70:	b7 1f       	adc	r27, r23
     f72:	c0 81       	ld	r28, Z
     f74:	cf 70       	andi	r28, 0x0F	; 15
     f76:	d0 e0       	ldi	r29, 0x00	; 0
     f78:	ca 5f       	subi	r28, 0xFA	; 250
     f7a:	df 4d       	sbci	r29, 0xDF	; 223
     f7c:	98 81       	ld	r25, Y
     f7e:	14 96       	adiw	r26, 0x04	; 4
     f80:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=' ';
     f82:	a0 91 c3 20 	lds	r26, 0x20C3
     f86:	b0 91 c4 20 	lds	r27, 0x20C4
     f8a:	a6 0f       	add	r26, r22
     f8c:	b7 1f       	adc	r27, r23
     f8e:	15 96       	adiw	r26, 0x05	; 5
     f90:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].SlaveAddress>>4) & 0x0f];	/* <High Nibble of SlaveAddress in ASCII> */
     f92:	a0 91 c3 20 	lds	r26, 0x20C3
     f96:	b0 91 c4 20 	lds	r27, 0x20C4
     f9a:	a6 0f       	add	r26, r22
     f9c:	b7 1f       	adc	r27, r23
     f9e:	c2 81       	ldd	r28, Z+2	; 0x02
     fa0:	c2 95       	swap	r28
     fa2:	cf 70       	andi	r28, 0x0F	; 15
     fa4:	d0 e0       	ldi	r29, 0x00	; 0
     fa6:	ca 5f       	subi	r28, 0xFA	; 250
     fa8:	df 4d       	sbci	r29, 0xDF	; 223
     faa:	98 81       	ld	r25, Y
     fac:	16 96       	adiw	r26, 0x06	; 6
     fae:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].SlaveAddress) & 0x0f];		/* <Lo Nibble of SlaveAddress in ASCII> */
     fb0:	a0 91 c3 20 	lds	r26, 0x20C3
     fb4:	b0 91 c4 20 	lds	r27, 0x20C4
     fb8:	a6 0f       	add	r26, r22
     fba:	b7 1f       	adc	r27, r23
     fbc:	c2 81       	ldd	r28, Z+2	; 0x02
     fbe:	cf 70       	andi	r28, 0x0F	; 15
     fc0:	d0 e0       	ldi	r29, 0x00	; 0
     fc2:	ca 5f       	subi	r28, 0xFA	; 250
     fc4:	df 4d       	sbci	r29, 0xDF	; 223
     fc6:	98 81       	ld	r25, Y
     fc8:	17 96       	adiw	r26, 0x07	; 7
     fca:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=' ';
     fcc:	a0 91 c3 20 	lds	r26, 0x20C3
     fd0:	b0 91 c4 20 	lds	r27, 0x20C4
     fd4:	a6 0f       	add	r26, r22
     fd6:	b7 1f       	adc	r27, r23
     fd8:	18 96       	adiw	r26, 0x08	; 8
     fda:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].Status.SensStatusVal>>4) & 0x0f];		/* <High Nibble of Status in ASCII> */
     fdc:	a0 91 c3 20 	lds	r26, 0x20C3
     fe0:	b0 91 c4 20 	lds	r27, 0x20C4
     fe4:	a6 0f       	add	r26, r22
     fe6:	b7 1f       	adc	r27, r23
     fe8:	c7 85       	ldd	r28, Z+15	; 0x0f
     fea:	c2 95       	swap	r28
     fec:	cf 70       	andi	r28, 0x0F	; 15
     fee:	d0 e0       	ldi	r29, 0x00	; 0
     ff0:	ca 5f       	subi	r28, 0xFA	; 250
     ff2:	df 4d       	sbci	r29, 0xDF	; 223
     ff4:	98 81       	ld	r25, Y
     ff6:	19 96       	adiw	r26, 0x09	; 9
     ff8:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].Status.SensStatusVal) & 0x0f];			/* <Lo Nibble of Status in ASCII> */
     ffa:	a0 91 c3 20 	lds	r26, 0x20C3
     ffe:	b0 91 c4 20 	lds	r27, 0x20C4
    1002:	a6 0f       	add	r26, r22
    1004:	b7 1f       	adc	r27, r23
    1006:	c7 85       	ldd	r28, Z+15	; 0x0f
    1008:	cf 70       	andi	r28, 0x0F	; 15
    100a:	d0 e0       	ldi	r29, 0x00	; 0
    100c:	ca 5f       	subi	r28, 0xFA	; 250
    100e:	df 4d       	sbci	r29, 0xDF	; 223
    1010:	98 81       	ld	r25, Y
    1012:	1a 96       	adiw	r26, 0x0a	; 10
    1014:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=' ';
    1016:	a0 91 c3 20 	lds	r26, 0x20C3
    101a:	b0 91 c4 20 	lds	r27, 0x20C4
    101e:	a6 0f       	add	r26, r22
    1020:	b7 1f       	adc	r27, r23
    1022:	1b 96       	adiw	r26, 0x0b	; 11
    1024:	8c 93       	st	X, r24
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].CurrentState>>4) & 0x0f];	/* <High Nibble of Status in ASCII> */
    1026:	a0 91 c3 20 	lds	r26, 0x20C3
    102a:	b0 91 c4 20 	lds	r27, 0x20C4
    102e:	a6 0f       	add	r26, r22
    1030:	b7 1f       	adc	r27, r23
    1032:	c5 85       	ldd	r28, Z+13	; 0x0d
    1034:	c2 95       	swap	r28
    1036:	cf 70       	andi	r28, 0x0F	; 15
    1038:	d0 e0       	ldi	r29, 0x00	; 0
    103a:	ca 5f       	subi	r28, 0xFA	; 250
    103c:	df 4d       	sbci	r29, 0xDF	; 223
    103e:	98 81       	ld	r25, Y
    1040:	1c 96       	adiw	r26, 0x0c	; 12
    1042:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].CurrentState) & 0x0f];		/* <Lo Nibble of Status in ASCII> */
    1044:	a0 91 c3 20 	lds	r26, 0x20C3
    1048:	b0 91 c4 20 	lds	r27, 0x20C4
    104c:	a6 0f       	add	r26, r22
    104e:	b7 1f       	adc	r27, r23
    1050:	e5 85       	ldd	r30, Z+13	; 0x0d
    1052:	ef 70       	andi	r30, 0x0F	; 15
    1054:	f0 e0       	ldi	r31, 0x00	; 0
    1056:	ea 5f       	subi	r30, 0xFA	; 250
    1058:	ff 4d       	sbci	r31, 0xDF	; 223
    105a:	90 81       	ld	r25, Z
    105c:	1d 96       	adiw	r26, 0x0d	; 13
    105e:	9c 93       	st	X, r25
	PCTXBuffer[RealPCTXBufferPointer++]=' ';
    1060:	e0 91 c3 20 	lds	r30, 0x20C3
    1064:	f0 91 c4 20 	lds	r31, 0x20C4
    1068:	e6 0f       	add	r30, r22
    106a:	f7 1f       	adc	r31, r23
    106c:	86 87       	std	Z+14, r24	; 0x0e
	return RealPCTXBufferPointer;
}
    106e:	cb 01       	movw	r24, r22
    1070:	0f 96       	adiw	r24, 0x0f	; 15
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <CopyDataToPCTXBuffer>:
 *
 *	Copy I2C sensors Data in PCTX Buffer
 *	Length: 8 bytes per sensor
*/
uint16_t CopyDataToPCTXBuffer(uint8_t SensorNumber, uint16_t PCTXCurrentPointer)
{
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
	int16_t RealPCTXBufferPointer = PCTXCurrentPointer;

	for (uint8_t DataPointer=0; DataPointer < SensorModule[SensorNumber].ReadBufLen; DataPointer++)
    107c:	40 e0       	ldi	r20, 0x00	; 0
    107e:	2f e1       	ldi	r18, 0x1F	; 31
    1080:	82 9f       	mul	r24, r18
    1082:	c0 01       	movw	r24, r0
    1084:	11 24       	eor	r1, r1
    1086:	89 52       	subi	r24, 0x29	; 41
    1088:	9f 4d       	sbci	r25, 0xDF	; 223
    108a:	9c 01       	movw	r18, r24
    108c:	27 5f       	subi	r18, 0xF7	; 247
    108e:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		/* <High Nibble of Data in ASCII> */
		PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].ReadBufer[DataPointer]&0xf0) >>4 ];
    1090:	ec 01       	movw	r28, r24
    1092:	27 96       	adiw	r28, 0x07	; 7
*/
uint16_t CopyDataToPCTXBuffer(uint8_t SensorNumber, uint16_t PCTXCurrentPointer)
{
	int16_t RealPCTXBufferPointer = PCTXCurrentPointer;

	for (uint8_t DataPointer=0; DataPointer < SensorModule[SensorNumber].ReadBufLen; DataPointer++)
    1094:	f9 01       	movw	r30, r18
    1096:	80 81       	ld	r24, Z
    1098:	48 17       	cp	r20, r24
    109a:	50 f5       	brcc	.+84     	; 0x10f0 <CopyDataToPCTXBuffer+0x78>
	{
		/* <High Nibble of Data in ASCII> */
		PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].ReadBufer[DataPointer]&0xf0) >>4 ];
    109c:	84 2f       	mov	r24, r20
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	e0 91 c3 20 	lds	r30, 0x20C3
    10a4:	f0 91 c4 20 	lds	r31, 0x20C4
    10a8:	e6 0f       	add	r30, r22
    10aa:	f7 1f       	adc	r31, r23
    10ac:	a8 81       	ld	r26, Y
    10ae:	b9 81       	ldd	r27, Y+1	; 0x01
    10b0:	a8 0f       	add	r26, r24
    10b2:	b9 1f       	adc	r27, r25
    10b4:	ac 91       	ld	r26, X
    10b6:	a2 95       	swap	r26
    10b8:	af 70       	andi	r26, 0x0F	; 15
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	aa 5f       	subi	r26, 0xFA	; 250
    10be:	bf 4d       	sbci	r27, 0xDF	; 223
    10c0:	5c 91       	ld	r21, X
    10c2:	50 83       	st	Z, r21
		/* <Low Nibble of Data in ASCII> */
		PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].ReadBufer[DataPointer]) & 0x0f];
    10c4:	6e 5f       	subi	r22, 0xFE	; 254
    10c6:	7f 4f       	sbci	r23, 0xFF	; 255
    10c8:	e0 91 c3 20 	lds	r30, 0x20C3
    10cc:	f0 91 c4 20 	lds	r31, 0x20C4
    10d0:	e6 0f       	add	r30, r22
    10d2:	f7 1f       	adc	r31, r23
    10d4:	31 97       	sbiw	r30, 0x01	; 1
    10d6:	a8 81       	ld	r26, Y
    10d8:	b9 81       	ldd	r27, Y+1	; 0x01
    10da:	a8 0f       	add	r26, r24
    10dc:	b9 1f       	adc	r27, r25
    10de:	ac 91       	ld	r26, X
    10e0:	af 70       	andi	r26, 0x0F	; 15
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
    10e4:	aa 5f       	subi	r26, 0xFA	; 250
    10e6:	bf 4d       	sbci	r27, 0xDF	; 223
    10e8:	8c 91       	ld	r24, X
    10ea:	80 83       	st	Z, r24
*/
uint16_t CopyDataToPCTXBuffer(uint8_t SensorNumber, uint16_t PCTXCurrentPointer)
{
	int16_t RealPCTXBufferPointer = PCTXCurrentPointer;

	for (uint8_t DataPointer=0; DataPointer < SensorModule[SensorNumber].ReadBufLen; DataPointer++)
    10ec:	4f 5f       	subi	r20, 0xFF	; 255
    10ee:	d2 cf       	rjmp	.-92     	; 0x1094 <CopyDataToPCTXBuffer+0x1c>
		PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].ReadBufer[DataPointer]&0xf0) >>4 ];
		/* <Low Nibble of Data in ASCII> */
		PCTXBuffer[RealPCTXBufferPointer++]=nybble_chars[(SensorModule[SensorNumber].ReadBufer[DataPointer]) & 0x0f];
	}
	return RealPCTXBufferPointer;
    10f0:	cb 01       	movw	r24, r22
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	08 95       	ret

000010f8 <CheckSensorBuffersForNewData>:
		}
	}
}

void CheckSensorBuffersForNewData(void)
{
    10f8:	0f 93       	push	r16
    10fa:	1f 93       	push	r17
    10fc:	cf 93       	push	r28
    10fe:	df 93       	push	r29
	PCTXBuffer[0] = NPFF;											/* <Packet first byte is always the FormFeed Character (0x0C)> */
    1100:	e0 91 c3 20 	lds	r30, 0x20C3
    1104:	f0 91 c4 20 	lds	r31, 0x20C4
    1108:	8c e0       	ldi	r24, 0x0C	; 12
    110a:	80 83       	st	Z, r24
	PCTXBuffer[1] = LF;												/* <Packet second byte is always the LineFeed Character (0x0A)> */
    110c:	e0 91 c3 20 	lds	r30, 0x20C3
    1110:	f0 91 c4 20 	lds	r31, 0x20C4
    1114:	2a e0       	ldi	r18, 0x0A	; 10
    1116:	21 83       	std	Z+1, r18	; 0x01
	//edit
	//sending packet length = 4 bytes
	PCTXBuffer[2] = nybble_chars[((PCTXBufferLen-7)&0xf000)>>12];
    1118:	e0 91 c3 20 	lds	r30, 0x20C3
    111c:	f0 91 c4 20 	lds	r31, 0x20C4
    1120:	80 91 c7 20 	lds	r24, 0x20C7
    1124:	90 91 c8 20 	lds	r25, 0x20C8
    1128:	07 97       	sbiw	r24, 0x07	; 7
    112a:	dc 01       	movw	r26, r24
    112c:	ab 2f       	mov	r26, r27
    112e:	bb 27       	eor	r27, r27
    1130:	a2 95       	swap	r26
    1132:	af 70       	andi	r26, 0x0F	; 15
    1134:	aa 5f       	subi	r26, 0xFA	; 250
    1136:	bf 4d       	sbci	r27, 0xDF	; 223
    1138:	3c 91       	ld	r19, X
    113a:	32 83       	std	Z+2, r19	; 0x02
	PCTXBuffer[3] = nybble_chars[((PCTXBufferLen-7)&0x0f00)>>8];
    113c:	dc 01       	movw	r26, r24
    113e:	aa 27       	eor	r26, r26
    1140:	bf 70       	andi	r27, 0x0F	; 15
    1142:	ab 2f       	mov	r26, r27
    1144:	bb 27       	eor	r27, r27
    1146:	aa 5f       	subi	r26, 0xFA	; 250
    1148:	bf 4d       	sbci	r27, 0xDF	; 223
    114a:	3c 91       	ld	r19, X
    114c:	33 83       	std	Z+3, r19	; 0x03
	PCTXBuffer[4] = nybble_chars[((PCTXBufferLen-7)&0x00f0)>>4];
    114e:	dc 01       	movw	r26, r24
    1150:	a0 7f       	andi	r26, 0xF0	; 240
    1152:	bb 27       	eor	r27, r27
    1154:	34 e0       	ldi	r19, 0x04	; 4
    1156:	b6 95       	lsr	r27
    1158:	a7 95       	ror	r26
    115a:	3a 95       	dec	r19
    115c:	e1 f7       	brne	.-8      	; 0x1156 <CheckSensorBuffersForNewData+0x5e>
    115e:	aa 5f       	subi	r26, 0xFA	; 250
    1160:	bf 4d       	sbci	r27, 0xDF	; 223
    1162:	3c 91       	ld	r19, X
    1164:	34 83       	std	Z+4, r19	; 0x04
	PCTXBuffer[5] = nybble_chars[((PCTXBufferLen-7)&0x000f)];
    1166:	dc 01       	movw	r26, r24
    1168:	af 70       	andi	r26, 0x0F	; 15
    116a:	bb 27       	eor	r27, r27
    116c:	aa 5f       	subi	r26, 0xFA	; 250
    116e:	bf 4d       	sbci	r27, 0xDF	; 223
    1170:	8c 91       	ld	r24, X
    1172:	85 83       	std	Z+5, r24	; 0x05
	PCTXBuffer[6] = LF;
    1174:	26 83       	std	Z+6, r18	; 0x06
	//current time (timestamp) must be inserted here
	uint16_t PCTXCurrentPointer = 7;
	//end of edit
	for(uint8_t i=0;i<I2CSENSNUM;i++)
    1176:	10 e0       	ldi	r17, 0x00	; 0
	{
		PCTXCurrentPointer = SensorModule[i].StartIndexInPCTXBuffer;
    1178:	0f e1       	ldi	r16, 0x1F	; 31
    117a:	01 9f       	mul	r16, r17
    117c:	e0 01       	movw	r28, r0
    117e:	11 24       	eor	r1, r1
    1180:	fe 01       	movw	r30, r28
    1182:	e9 52       	subi	r30, 0x29	; 41
    1184:	ff 4d       	sbci	r31, 0xDF	; 223
    1186:	62 85       	ldd	r22, Z+10	; 0x0a
    1188:	73 85       	ldd	r23, Z+11	; 0x0b
		PCTXCurrentPointer = CopySensorHeaderToPCTXBuffer(i,PCTXCurrentPointer);
    118a:	81 2f       	mov	r24, r17
    118c:	0e 94 77 07 	call	0xeee	; 0xeee <CopySensorHeaderToPCTXBuffer>
    1190:	bc 01       	movw	r22, r24
		if(SensorModule[i].Status.NewData)
    1192:	ca 51       	subi	r28, 0x1A	; 26
    1194:	df 4d       	sbci	r29, 0xDF	; 223
    1196:	88 81       	ld	r24, Y
    1198:	83 ff       	sbrs	r24, 3
    119a:	0c c0       	rjmp	.+24     	; 0x11b4 <CheckSensorBuffersForNewData+0xbc>
		{
			/* <timestamp must be copied here from stucture> */
			SensorModule[i].Status.NewData = 0;
    119c:	87 7f       	andi	r24, 0xF7	; 247
    119e:	88 83       	st	Y, r24
			PCTXCurrentPointer = CopyDataToPCTXBuffer(i,PCTXCurrentPointer);
    11a0:	81 2f       	mov	r24, r17
    11a2:	0e 94 3c 08 	call	0x1078	; 0x1078 <CopyDataToPCTXBuffer>
			/* <while copying data, new data came so repeat this copy cycle with valid data> */
			if(SensorModule[i].Status.NewData){i--;}				
    11a6:	88 81       	ld	r24, Y
    11a8:	83 ff       	sbrs	r24, 3
    11aa:	02 c0       	rjmp	.+4      	; 0x11b0 <CheckSensorBuffersForNewData+0xb8>
    11ac:	11 50       	subi	r17, 0x01	; 1
    11ae:	02 c0       	rjmp	.+4      	; 0x11b4 <CheckSensorBuffersForNewData+0xbc>
			else{SensorModule[i].Status.NewDataCopied=1;}
    11b0:	80 61       	ori	r24, 0x10	; 16
    11b2:	88 83       	st	Y, r24
		}
		PCTXCurrentPointer = SensorModule[i].StartIndexInPCTXBuffer+SensorModule[i].PCTXLen - 1;
    11b4:	01 9f       	mul	r16, r17
    11b6:	f0 01       	movw	r30, r0
    11b8:	11 24       	eor	r1, r1
    11ba:	e9 52       	subi	r30, 0x29	; 41
    11bc:	ff 4d       	sbci	r31, 0xDF	; 223
    11be:	22 85       	ldd	r18, Z+10	; 0x0a
    11c0:	33 85       	ldd	r19, Z+11	; 0x0b
    11c2:	21 50       	subi	r18, 0x01	; 1
    11c4:	31 09       	sbc	r19, r1
    11c6:	84 85       	ldd	r24, Z+12	; 0x0c
		PCTXCurrentPointer = PutSensorSeparatorInPCTXBuffer(PCTXCurrentPointer);					/* <LF 1 byte> */
    11c8:	a9 01       	movw	r20, r18
    11ca:	48 0f       	add	r20, r24
    11cc:	51 1d       	adc	r21, r1
    11ce:	ca 01       	movw	r24, r20
    11d0:	0e 94 64 06 	call	0xcc8	; 0xcc8 <PutSensorSeparatorInPCTXBuffer>
	PCTXBuffer[5] = nybble_chars[((PCTXBufferLen-7)&0x000f)];
	PCTXBuffer[6] = LF;
	//current time (timestamp) must be inserted here
	uint16_t PCTXCurrentPointer = 7;
	//end of edit
	for(uint8_t i=0;i<I2CSENSNUM;i++)
    11d4:	1f 5f       	subi	r17, 0xFF	; 255
    11d6:	15 30       	cpi	r17, 0x05	; 5
    11d8:	80 f2       	brcs	.-96     	; 0x117a <CheckSensorBuffersForNewData+0x82>
		PCTXCurrentPointer = SensorModule[i].StartIndexInPCTXBuffer+SensorModule[i].PCTXLen - 1;
		PCTXCurrentPointer = PutSensorSeparatorInPCTXBuffer(PCTXCurrentPointer);					/* <LF 1 byte> */
	}
	
	/* <Copy Batteries info + data in PCTXBuffer> */
	PCTXCurrentPointer = copyBatteriesInfo_PCTXBuffer(PCTXCurrentPointer);
    11da:	0e 94 6e 06 	call	0xcdc	; 0xcdc <copyBatteriesInfo_PCTXBuffer>
	/* <Copy Encoder info + data in PCTXBuffer> */
	PCTXCurrentPointer = copyEncoderInfo_PCTXBuffer(PCTXCurrentPointer);
    11de:	0e 94 0d 07 	call	0xe1a	; 0xe1a <copyEncoderInfo_PCTXBuffer>
	
	PCTXBufferCrc=0;
    11e2:	10 92 be 20 	sts	0x20BE, r1
    11e6:	10 92 bf 20 	sts	0x20BF, r1
	for(int i=0; i<PCTXBufferLen-5; i++)
    11ea:	40 91 c7 20 	lds	r20, 0x20C7
    11ee:	50 91 c8 20 	lds	r21, 0x20C8
    11f2:	45 50       	subi	r20, 0x05	; 5
    11f4:	51 09       	sbc	r21, r1
    11f6:	20 91 c3 20 	lds	r18, 0x20C3
    11fa:	30 91 c4 20 	lds	r19, 0x20C4
    11fe:	f9 01       	movw	r30, r18
    1200:	bf 01       	movw	r22, r30
    1202:	62 1b       	sub	r22, r18
    1204:	73 0b       	sbc	r23, r19
    1206:	64 17       	cp	r22, r20
    1208:	75 07       	cpc	r23, r21
    120a:	60 f4       	brcc	.+24     	; 0x1224 <CheckSensorBuffersForNewData+0x12c>
		PCTXBufferCrc+=(int)PCTXBuffer[i];
    120c:	a1 91       	ld	r26, Z+
    120e:	60 91 be 20 	lds	r22, 0x20BE
    1212:	70 91 bf 20 	lds	r23, 0x20BF
    1216:	6a 0f       	add	r22, r26
    1218:	71 1d       	adc	r23, r1
    121a:	60 93 be 20 	sts	0x20BE, r22
    121e:	70 93 bf 20 	sts	0x20BF, r23
    1222:	ee cf       	rjmp	.-36     	; 0x1200 <CheckSensorBuffersForNewData+0x108>
	PCTXBuffer[PCTXCurrentPointer++]=nybble_chars[(PCTXBufferCrc&0xf000)>>12];
    1224:	f9 01       	movw	r30, r18
    1226:	e8 0f       	add	r30, r24
    1228:	f9 1f       	adc	r31, r25
    122a:	40 91 bf 20 	lds	r20, 0x20BF
    122e:	24 2f       	mov	r18, r20
    1230:	22 95       	swap	r18
    1232:	2f 70       	andi	r18, 0x0F	; 15
    1234:	30 e0       	ldi	r19, 0x00	; 0
    1236:	d9 01       	movw	r26, r18
    1238:	aa 5f       	subi	r26, 0xFA	; 250
    123a:	bf 4d       	sbci	r27, 0xDF	; 223
    123c:	2c 91       	ld	r18, X
    123e:	20 83       	st	Z, r18
	PCTXBuffer[PCTXCurrentPointer++]=nybble_chars[(PCTXBufferCrc&0x0f00)>>8];
    1240:	e0 91 c3 20 	lds	r30, 0x20C3
    1244:	f0 91 c4 20 	lds	r31, 0x20C4
    1248:	e8 0f       	add	r30, r24
    124a:	f9 1f       	adc	r31, r25
    124c:	a0 91 be 20 	lds	r26, 0x20BE
    1250:	b0 91 bf 20 	lds	r27, 0x20BF
    1254:	aa 27       	eor	r26, r26
    1256:	bf 70       	andi	r27, 0x0F	; 15
    1258:	ab 2f       	mov	r26, r27
    125a:	bb 27       	eor	r27, r27
    125c:	aa 5f       	subi	r26, 0xFA	; 250
    125e:	bf 4d       	sbci	r27, 0xDF	; 223
    1260:	2c 91       	ld	r18, X
    1262:	21 83       	std	Z+1, r18	; 0x01
	PCTXBuffer[PCTXCurrentPointer++]=nybble_chars[(PCTXBufferCrc&0x00f0)>>4];
    1264:	a0 91 c3 20 	lds	r26, 0x20C3
    1268:	b0 91 c4 20 	lds	r27, 0x20C4
    126c:	a8 0f       	add	r26, r24
    126e:	b9 1f       	adc	r27, r25
    1270:	e0 91 be 20 	lds	r30, 0x20BE
    1274:	f0 91 bf 20 	lds	r31, 0x20BF
    1278:	e0 7f       	andi	r30, 0xF0	; 240
    127a:	ff 27       	eor	r31, r31
    127c:	d4 e0       	ldi	r29, 0x04	; 4
    127e:	f6 95       	lsr	r31
    1280:	e7 95       	ror	r30
    1282:	da 95       	dec	r29
    1284:	e1 f7       	brne	.-8      	; 0x127e <CheckSensorBuffersForNewData+0x186>
    1286:	ea 5f       	subi	r30, 0xFA	; 250
    1288:	ff 4d       	sbci	r31, 0xDF	; 223
    128a:	20 81       	ld	r18, Z
    128c:	12 96       	adiw	r26, 0x02	; 2
    128e:	2c 93       	st	X, r18
	PCTXBuffer[PCTXCurrentPointer++]=nybble_chars[(PCTXBufferCrc&0x000f)];
    1290:	a0 91 c3 20 	lds	r26, 0x20C3
    1294:	b0 91 c4 20 	lds	r27, 0x20C4
    1298:	a8 0f       	add	r26, r24
    129a:	b9 1f       	adc	r27, r25
    129c:	e0 91 be 20 	lds	r30, 0x20BE
    12a0:	f0 91 bf 20 	lds	r31, 0x20BF
    12a4:	ef 70       	andi	r30, 0x0F	; 15
    12a6:	ff 27       	eor	r31, r31
    12a8:	ea 5f       	subi	r30, 0xFA	; 250
    12aa:	ff 4d       	sbci	r31, 0xDF	; 223
    12ac:	20 81       	ld	r18, Z
    12ae:	13 96       	adiw	r26, 0x03	; 3
    12b0:	2c 93       	st	X, r18
	PCTXBuffer[PCTXCurrentPointer]=EOT;											/* <End of transmission Character> */
    12b2:	e0 91 c3 20 	lds	r30, 0x20C3
    12b6:	f0 91 c4 20 	lds	r31, 0x20C4
    12ba:	e8 0f       	add	r30, r24
    12bc:	f9 1f       	adc	r31, r25
    12be:	84 e0       	ldi	r24, 0x04	; 4
    12c0:	84 83       	std	Z+4, r24	; 0x04
}
    12c2:	df 91       	pop	r29
    12c4:	cf 91       	pop	r28
    12c6:	1f 91       	pop	r17
    12c8:	0f 91       	pop	r16
    12ca:	08 95       	ret

000012cc <CreateSensorStructs>:
/*!< An array of i2c_sensor_struct objects. Holding i2c sensors info */
i2c_sensor_struct SensorModule[I2CSENSNUM];


uint16_t CreateSensorStructs(void)
{
    12cc:	2f 92       	push	r2
    12ce:	3f 92       	push	r3
    12d0:	4f 92       	push	r4
    12d2:	5f 92       	push	r5
    12d4:	6f 92       	push	r6
    12d6:	7f 92       	push	r7
    12d8:	8f 92       	push	r8
    12da:	9f 92       	push	r9
    12dc:	af 92       	push	r10
    12de:	bf 92       	push	r11
    12e0:	cf 92       	push	r12
    12e2:	df 92       	push	r13
    12e4:	ef 92       	push	r14
    12e6:	ff 92       	push	r15
    12e8:	0f 93       	push	r16
    12ea:	1f 93       	push	r17
    12ec:	cf 93       	push	r28
    12ee:	df 93       	push	r29
    12f0:	cd b7       	in	r28, 0x3d	; 61
    12f2:	de b7       	in	r29, 0x3e	; 62
    12f4:	25 97       	sbiw	r28, 0x05	; 5
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	de bf       	out	0x3e, r29	; 62
    12fa:	67 ed       	ldi	r22, 0xD7	; 215
    12fc:	70 e2       	ldi	r23, 0x20	; 32
    12fe:	80 ee       	ldi	r24, 0xE0	; 224
    1300:	c8 2e       	mov	r12, r24
    1302:	80 e2       	ldi	r24, 0x20	; 32
    1304:	d8 2e       	mov	r13, r24
    1306:	31 2c       	mov	r3, r1
    1308:	a1 2c       	mov	r10, r1
    130a:	b1 2c       	mov	r11, r1
    130c:	41 2c       	mov	r4, r1
    130e:	51 2c       	mov	r5, r1
	//edit was 2 , now 7 + 4 CRC
	uint16_t	PCTXBufferLenCr=7;		/* <NPFF + LF + 4 bytes Length + LF> */
    1310:	97 e0       	ldi	r25, 0x07	; 7
    1312:	e9 2e       	mov	r14, r25
    1314:	f1 2c       	mov	r15, r1
		SensorModule[i].Groupmember = I2CAddressLUT[i][2];
		SensorModule[i].SensorID = i;
		switch (SensorModule[i].type)
		{
			case SRF05tinym:
			SensorModule[i].WriteBufLen = SRF05tiny_WRITE_LEN;
    1316:	22 24       	eor	r2, r2
    1318:	23 94       	inc	r2
			SensorModule[i].ReadBufLen = SRF05tiny_READ_LEN;
    131a:	24 e0       	ldi	r18, 0x04	; 4
			SensorModule[i].ReadBufer = malloc(SRF05tiny_READ_LEN * sizeof(uint8_t));
			SensorModule[i].WriteBufer = malloc(SRF05tiny_WRITE_LEN * sizeof(uint8_t));
			SensorModule[i].WriteBufer[0] = 0x80;			/* <Trigger Command> */
    131c:	30 e8       	ldi	r19, 0x80	; 128
			SensorModule[i].WriteBufer[1] = 0x40;			/* <Read Range Command> */
    131e:	40 e4       	ldi	r20, 0x40	; 64
			SensorModule[i].CurrentState = ReviveState;									/* <Starting in Revive State> */
			SensorModule[i].ReviveStateDuration = SRF05tinyWaitReviveSensorCounts;
    1320:	54 ef       	ldi	r21, 0xF4	; 244
    1322:	85 2e       	mov	r8, r21
    1324:	99 24       	eor	r9, r9
    1326:	93 94       	inc	r9
			SensorModule[i].IdleState1Duration = SRF05tinyDelayAfterNack;
    1328:	e5 e0       	ldi	r30, 0x05	; 5
    132a:	6e 2e       	mov	r6, r30
    132c:	71 2c       	mov	r7, r1
    132e:	f2 01       	movw	r30, r4
    1330:	e9 5e       	subi	r30, 0xE9	; 233
    1332:	ff 4d       	sbci	r31, 0xDF	; 223
	//edit was 2 , now 7 + 4 CRC
	uint16_t	PCTXBufferLenCr=7;		/* <NPFF + LF + 4 bytes Length + LF> */
	//end of edit
	for ( int i = 0 ; i < I2CSENSNUM; i++)
	{
		SensorModule[i].type = I2CAddressLUT[i][0];
    1334:	80 81       	ld	r24, Z
    1336:	db 01       	movw	r26, r22
    1338:	8c 93       	st	X, r24
    133a:	85 01       	movw	r16, r10
    133c:	09 52       	subi	r16, 0x29	; 41
    133e:	1f 4d       	sbci	r17, 0xDF	; 223
		SensorModule[i].SlaveAddress = I2CAddressLUT[i][1];
    1340:	81 81       	ldd	r24, Z+1	; 0x01
    1342:	d8 01       	movw	r26, r16
    1344:	12 96       	adiw	r26, 0x02	; 2
    1346:	8c 93       	st	X, r24
    1348:	12 97       	sbiw	r26, 0x02	; 2
		SensorModule[i].Groupmember = I2CAddressLUT[i][2];
    134a:	82 81       	ldd	r24, Z+2	; 0x02
    134c:	13 96       	adiw	r26, 0x03	; 3
    134e:	8c 93       	st	X, r24
    1350:	13 97       	sbiw	r26, 0x03	; 3
		SensorModule[i].SensorID = i;
    1352:	11 96       	adiw	r26, 0x01	; 1
    1354:	3c 92       	st	X, r3
    1356:	11 97       	sbiw	r26, 0x01	; 1
		switch (SensorModule[i].type)
    1358:	fb 01       	movw	r30, r22
    135a:	80 81       	ld	r24, Z
    135c:	81 11       	cpse	r24, r1
    135e:	2d c0       	rjmp	.+90     	; 0x13ba <CreateSensorStructs+0xee>
		{
			case SRF05tinym:
			SensorModule[i].WriteBufLen = SRF05tiny_WRITE_LEN;
    1360:	16 96       	adiw	r26, 0x06	; 6
    1362:	2c 92       	st	X, r2
			SensorModule[i].ReadBufLen = SRF05tiny_READ_LEN;
    1364:	d6 01       	movw	r26, r12
    1366:	2c 93       	st	X, r18
			SensorModule[i].ReadBufer = malloc(SRF05tiny_READ_LEN * sizeof(uint8_t));
    1368:	84 e0       	ldi	r24, 0x04	; 4
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	2b 83       	std	Y+3, r18	; 0x03
    136e:	3c 83       	std	Y+4, r19	; 0x04
    1370:	4d 83       	std	Y+5, r20	; 0x05
    1372:	69 83       	std	Y+1, r22	; 0x01
    1374:	7a 83       	std	Y+2, r23	; 0x02
    1376:	0e 94 3e 0c 	call	0x187c	; 0x187c <malloc>
    137a:	69 81       	ldd	r22, Y+1	; 0x01
    137c:	7a 81       	ldd	r23, Y+2	; 0x02
    137e:	fb 01       	movw	r30, r22
    1380:	87 83       	std	Z+7, r24	; 0x07
    1382:	90 87       	std	Z+8, r25	; 0x08
			SensorModule[i].WriteBufer = malloc(SRF05tiny_WRITE_LEN * sizeof(uint8_t));
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	69 83       	std	Y+1, r22	; 0x01
    138a:	7a 83       	std	Y+2, r23	; 0x02
    138c:	0e 94 3e 0c 	call	0x187c	; 0x187c <malloc>
    1390:	69 81       	ldd	r22, Y+1	; 0x01
    1392:	7a 81       	ldd	r23, Y+2	; 0x02
    1394:	db 01       	movw	r26, r22
    1396:	14 96       	adiw	r26, 0x04	; 4
    1398:	8d 93       	st	X+, r24
    139a:	9c 93       	st	X, r25
    139c:	15 97       	sbiw	r26, 0x05	; 5
			SensorModule[i].WriteBufer[0] = 0x80;			/* <Trigger Command> */
    139e:	3c 81       	ldd	r19, Y+4	; 0x04
    13a0:	fc 01       	movw	r30, r24
    13a2:	30 83       	st	Z, r19
			SensorModule[i].WriteBufer[1] = 0x40;			/* <Read Range Command> */
    13a4:	4d 81       	ldd	r20, Y+5	; 0x05
    13a6:	41 83       	std	Z+1, r20	; 0x01
			SensorModule[i].CurrentState = ReviveState;									/* <Starting in Revive State> */
    13a8:	d8 01       	movw	r26, r16
    13aa:	1d 96       	adiw	r26, 0x0d	; 13
    13ac:	1c 92       	st	X, r1
			SensorModule[i].ReviveStateDuration = SRF05tinyWaitReviveSensorCounts;
    13ae:	fb 01       	movw	r30, r22
    13b0:	87 8a       	std	Z+23, r8	; 0x17
    13b2:	90 8e       	std	Z+24, r9	; 0x18
			SensorModule[i].IdleState1Duration = SRF05tinyDelayAfterNack;
    13b4:	63 8e       	std	Z+27, r6	; 0x1b
    13b6:	74 8e       	std	Z+28, r7	; 0x1c
    13b8:	2b 81       	ldd	r18, Y+3	; 0x03
			break;
			default:
			break;
		}
		SensorModule[i].WaitCount1 = 0;									
    13ba:	db 01       	movw	r26, r22
    13bc:	51 96       	adiw	r26, 0x11	; 17
    13be:	1d 92       	st	X+, r1
    13c0:	1c 92       	st	X, r1
    13c2:	52 97       	sbiw	r26, 0x12	; 18
		SensorModule[i].ComErrorCounts = 0;
    13c4:	f8 01       	movw	r30, r16
    13c6:	15 8e       	std	Z+29, r1	; 0x1d
		SensorModule[i].Status.SensStatusVal = 0;
    13c8:	17 86       	std	Z+15, r1	; 0x0f
		SensorModule[i].visitstoread = 0;
    13ca:	16 8e       	std	Z+30, r1	; 0x1e
		SensorModule[i].StartIndexInPCTXBuffer = PCTXBufferLenCr;
    13cc:	1a 96       	adiw	r26, 0x0a	; 10
    13ce:	ed 92       	st	X+, r14
    13d0:	fc 92       	st	X, r15
    13d2:	1b 97       	sbiw	r26, 0x0b	; 11
		SensorModule[i].PCTXLen = ((SensorModule[i].ReadBufLen+5)*2+1+5)*sizeof(uint8_t);
    13d4:	d6 01       	movw	r26, r12
    13d6:	8c 91       	ld	r24, X
    13d8:	88 0f       	add	r24, r24
    13da:	80 5f       	subi	r24, 0xF0	; 240
    13dc:	84 87       	std	Z+12, r24	; 0x0c
		PCTXBufferLenCr += SensorModule[i].PCTXLen;
    13de:	e8 0e       	add	r14, r24
    13e0:	f1 1c       	adc	r15, r1
    13e2:	b3 e0       	ldi	r27, 0x03	; 3
    13e4:	4b 0e       	add	r4, r27
    13e6:	51 1c       	adc	r5, r1
    13e8:	ef e1       	ldi	r30, 0x1F	; 31
    13ea:	ae 0e       	add	r10, r30
    13ec:	b1 1c       	adc	r11, r1
    13ee:	61 5e       	subi	r22, 0xE1	; 225
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	33 94       	inc	r3
    13f4:	ff e1       	ldi	r31, 0x1F	; 31
    13f6:	cf 0e       	add	r12, r31
    13f8:	d1 1c       	adc	r13, r1
uint16_t CreateSensorStructs(void)
{
	//edit was 2 , now 7 + 4 CRC
	uint16_t	PCTXBufferLenCr=7;		/* <NPFF + LF + 4 bytes Length + LF> */
	//end of edit
	for ( int i = 0 ; i < I2CSENSNUM; i++)
    13fa:	85 e0       	ldi	r24, 0x05	; 5
    13fc:	38 12       	cpse	r3, r24
    13fe:	97 cf       	rjmp	.-210    	; 0x132e <CreateSensorStructs+0x62>
		SensorModule[i].PCTXLen = ((SensorModule[i].ReadBufLen+5)*2+1+5)*sizeof(uint8_t);
		PCTXBufferLenCr += SensorModule[i].PCTXLen;
	}
	return PCTXBufferLenCr + 13 + 5 + 10;			/* <13 added for battery values, 5 added for CRC, 10 for encoder> */
	
    1400:	c7 01       	movw	r24, r14
    1402:	4c 96       	adiw	r24, 0x1c	; 28
    1404:	25 96       	adiw	r28, 0x05	; 5
    1406:	cd bf       	out	0x3d, r28	; 61
    1408:	de bf       	out	0x3e, r29	; 62
    140a:	df 91       	pop	r29
    140c:	cf 91       	pop	r28
    140e:	1f 91       	pop	r17
    1410:	0f 91       	pop	r16
    1412:	ff 90       	pop	r15
    1414:	ef 90       	pop	r14
    1416:	df 90       	pop	r13
    1418:	cf 90       	pop	r12
    141a:	bf 90       	pop	r11
    141c:	af 90       	pop	r10
    141e:	9f 90       	pop	r9
    1420:	8f 90       	pop	r8
    1422:	7f 90       	pop	r7
    1424:	6f 90       	pop	r6
    1426:	5f 90       	pop	r5
    1428:	4f 90       	pop	r4
    142a:	3f 90       	pop	r3
    142c:	2f 90       	pop	r2
    142e:	08 95       	ret

00001430 <main>:
#include "xMega.h"

static void tcc0_ovf_interrupt_callback(void);

int main(void) 
{
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
	uint8_t i;
	NextSensor=0;
    1434:	10 92 3b 20 	sts	0x203B, r1
	PCTXPointer=0;
    1438:	10 92 c5 20 	sts	0x20C5, r1
    143c:	10 92 c6 20 	sts	0x20C6, r1
	
	_startup_system_init();
    1440:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <_startup_system_init>
	/* Sensor Structure Init*/
	PCTXBufferLen=CreateSensorStructs();
    1444:	0e 94 66 09 	call	0x12cc	; 0x12cc <CreateSensorStructs>
    1448:	80 93 c7 20 	sts	0x20C7, r24
    144c:	90 93 c8 20 	sts	0x20C8, r25
	/* Select Sensors that belong in Group1 and clear their 'USED' Flag*/
	CurrentGroup=1;
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	80 93 38 20 	sts	0x2038, r24
	CreateArraySameGroupIDs();
    1456:	0e 94 2b 05 	call	0xa56	; 0xa56 <CreateArraySameGroupIDs>
	
	PCTXBuffer = malloc(PCTXBufferLen * sizeof(uint8_t));
    145a:	80 91 c7 20 	lds	r24, 0x20C7
    145e:	90 91 c8 20 	lds	r25, 0x20C8
    1462:	0e 94 3e 0c 	call	0x187c	; 0x187c <malloc>
    1466:	80 93 c3 20 	sts	0x20C3, r24
    146a:	90 93 c4 20 	sts	0x20C4, r25
	for (uint16_t j=0; j<PCTXBufferLen;j++)	{PCTXBuffer[j] ='0';}
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	40 e3       	ldi	r20, 0x30	; 48
    1474:	20 91 c7 20 	lds	r18, 0x20C7
    1478:	30 91 c8 20 	lds	r19, 0x20C8
    147c:	82 17       	cp	r24, r18
    147e:	93 07       	cpc	r25, r19
    1480:	48 f4       	brcc	.+18     	; 0x1494 <main+0x64>
    1482:	e0 91 c3 20 	lds	r30, 0x20C3
    1486:	f0 91 c4 20 	lds	r31, 0x20C4
    148a:	e8 0f       	add	r30, r24
    148c:	f9 1f       	adc	r31, r25
    148e:	40 83       	st	Z, r20
    1490:	01 96       	adiw	r24, 0x01	; 1
    1492:	f0 cf       	rjmp	.-32     	; 0x1474 <main+0x44>
    1494:	e1 ee       	ldi	r30, 0xE1	; 225
    1496:	f0 e2       	ldi	r31, 0x20	; 32
    1498:	c6 e2       	ldi	r28, 0x26	; 38
    149a:	d0 e2       	ldi	r29, 0x20	; 32
		
	for(i=0;i<I2CSENSNUM;i++)
	{
		PCTXBuffer[SensorModule[i].StartIndexInPCTXBuffer] = nybble_chars[(i & 0xf0)>>4];
    149c:	30 e3       	ldi	r19, 0x30	; 48
    149e:	a0 91 c3 20 	lds	r26, 0x20C3
    14a2:	b0 91 c4 20 	lds	r27, 0x20C4
    14a6:	80 81       	ld	r24, Z
    14a8:	91 81       	ldd	r25, Z+1	; 0x01
    14aa:	a8 0f       	add	r26, r24
    14ac:	b9 1f       	adc	r27, r25
    14ae:	3c 93       	st	X, r19
		PCTXBuffer[SensorModule[i].StartIndexInPCTXBuffer+1] = nybble_chars[(i & 0x0f)];
    14b0:	29 91       	ld	r18, Y+
    14b2:	a0 91 c3 20 	lds	r26, 0x20C3
    14b6:	b0 91 c4 20 	lds	r27, 0x20C4
    14ba:	80 81       	ld	r24, Z
    14bc:	91 81       	ldd	r25, Z+1	; 0x01
    14be:	a8 0f       	add	r26, r24
    14c0:	b9 1f       	adc	r27, r25
    14c2:	11 96       	adiw	r26, 0x01	; 1
    14c4:	2c 93       	st	X, r18
    14c6:	7f 96       	adiw	r30, 0x1f	; 31
	CreateArraySameGroupIDs();
	
	PCTXBuffer = malloc(PCTXBufferLen * sizeof(uint8_t));
	for (uint16_t j=0; j<PCTXBufferLen;j++)	{PCTXBuffer[j] ='0';}
		
	for(i=0;i<I2CSENSNUM;i++)
    14c8:	81 e2       	ldi	r24, 0x21	; 33
    14ca:	ec 37       	cpi	r30, 0x7C	; 124
    14cc:	f8 07       	cpc	r31, r24
    14ce:	39 f7       	brne	.-50     	; 0x149e <main+0x6e>
	{
		PCTXBuffer[SensorModule[i].StartIndexInPCTXBuffer] = nybble_chars[(i & 0xf0)>>4];
		PCTXBuffer[SensorModule[i].StartIndexInPCTXBuffer+1] = nybble_chars[(i & 0x0f)];
	}
	PCTXBuffer[0] = NPFF;
    14d0:	e0 91 c3 20 	lds	r30, 0x20C3
    14d4:	f0 91 c4 20 	lds	r31, 0x20C4
    14d8:	8c e0       	ldi	r24, 0x0C	; 12
    14da:	80 83       	st	Z, r24
	PCTXBuffer[1] = SOH;
    14dc:	e0 91 c3 20 	lds	r30, 0x20C3
    14e0:	f0 91 c4 20 	lds	r31, 0x20C4
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	81 83       	std	Z+1, r24	; 0x01
	
	sei();
    14e8:	78 94       	sei
	i= 0;
	
	pandora_fsm();
    14ea:	0e 94 ed 02 	call	0x5da	; 0x5da <pandora_fsm>
	
	return 0;
}
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	08 95       	ret

000014f8 <__vector_13>:

/************************************************************************/
/* Interrupt Handlers for I2C and TimerCounter0                          */
/************************************************************************/
ISR(TWIC_TWIM_vect)
{
    14f8:	1f 92       	push	r1
    14fa:	0f 92       	push	r0
    14fc:	0f b6       	in	r0, 0x3f	; 63
    14fe:	0f 92       	push	r0
    1500:	11 24       	eor	r1, r1
    1502:	08 b6       	in	r0, 0x38	; 56
    1504:	0f 92       	push	r0
    1506:	18 be       	out	0x38, r1	; 56
    1508:	09 b6       	in	r0, 0x39	; 57
    150a:	0f 92       	push	r0
    150c:	19 be       	out	0x39, r1	; 57
    150e:	0b b6       	in	r0, 0x3b	; 59
    1510:	0f 92       	push	r0
    1512:	1b be       	out	0x3b, r1	; 59
    1514:	2f 93       	push	r18
    1516:	3f 93       	push	r19
    1518:	4f 93       	push	r20
    151a:	5f 93       	push	r21
    151c:	6f 93       	push	r22
    151e:	7f 93       	push	r23
    1520:	8f 93       	push	r24
    1522:	9f 93       	push	r25
    1524:	af 93       	push	r26
    1526:	bf 93       	push	r27
    1528:	ef 93       	push	r30
    152a:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twiMaster);
    152c:	82 e7       	ldi	r24, 0x72	; 114
    152e:	91 e2       	ldi	r25, 0x21	; 33
    1530:	0e 94 48 02 	call	0x490	; 0x490 <TWI_MasterInterruptHandler>
}
    1534:	ff 91       	pop	r31
    1536:	ef 91       	pop	r30
    1538:	bf 91       	pop	r27
    153a:	af 91       	pop	r26
    153c:	9f 91       	pop	r25
    153e:	8f 91       	pop	r24
    1540:	7f 91       	pop	r23
    1542:	6f 91       	pop	r22
    1544:	5f 91       	pop	r21
    1546:	4f 91       	pop	r20
    1548:	3f 91       	pop	r19
    154a:	2f 91       	pop	r18
    154c:	0f 90       	pop	r0
    154e:	0b be       	out	0x3b, r0	; 59
    1550:	0f 90       	pop	r0
    1552:	09 be       	out	0x39, r0	; 57
    1554:	0f 90       	pop	r0
    1556:	08 be       	out	0x38, r0	; 56
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63
    155c:	0f 90       	pop	r0
    155e:	1f 90       	pop	r1
    1560:	18 95       	reti

00001562 <__vector_14>:

ISR(TCC0_OVF_vect)
{
    1562:	1f 92       	push	r1
    1564:	0f 92       	push	r0
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	0f 92       	push	r0
    156a:	11 24       	eor	r1, r1
    156c:	08 b6       	in	r0, 0x38	; 56
    156e:	0f 92       	push	r0
    1570:	18 be       	out	0x38, r1	; 56
    1572:	09 b6       	in	r0, 0x39	; 57
    1574:	0f 92       	push	r0
    1576:	19 be       	out	0x39, r1	; 57
    1578:	0b b6       	in	r0, 0x3b	; 59
    157a:	0f 92       	push	r0
    157c:	1b be       	out	0x3b, r1	; 59
    157e:	2f 93       	push	r18
    1580:	3f 93       	push	r19
    1582:	4f 93       	push	r20
    1584:	5f 93       	push	r21
    1586:	6f 93       	push	r22
    1588:	7f 93       	push	r23
    158a:	8f 93       	push	r24
    158c:	9f 93       	push	r25
    158e:	af 93       	push	r26
    1590:	bf 93       	push	r27
    1592:	ef 93       	push	r30
    1594:	ff 93       	push	r31
}

//-----------------------------------------------------------------------------------------------------------
static void tcc0_ovf_interrupt_callback(void)
{
	TCTimingFlags |=Tick200us;
    1596:	80 91 3c 20 	lds	r24, 0x203C
    159a:	81 60       	ori	r24, 0x01	; 1
    159c:	80 93 3c 20 	sts	0x203C, r24

	NextSensor = I2CSensorFSMCore(NextSensor);
    15a0:	80 91 3b 20 	lds	r24, 0x203B
    15a4:	0e 94 b8 05 	call	0xb70	; 0xb70 <I2CSensorFSMCore>
    15a8:	80 93 3b 20 	sts	0x203B, r24

	if(!(ticks % 2)) {TCTimingFlags |=Tick400us;}
    15ac:	80 91 bc 20 	lds	r24, 0x20BC
    15b0:	90 91 bd 20 	lds	r25, 0x20BD
    15b4:	80 fd       	sbrc	r24, 0
    15b6:	05 c0       	rjmp	.+10     	; 0x15c2 <__vector_14+0x60>
    15b8:	80 91 3c 20 	lds	r24, 0x203C
    15bc:	82 60       	ori	r24, 0x02	; 2
    15be:	80 93 3c 20 	sts	0x203C, r24
	if(!(ticks % 4)) {}
    15c2:	80 91 bc 20 	lds	r24, 0x20BC
    15c6:	90 91 bd 20 	lds	r25, 0x20BD

	if(!(ticks % 5))
    15ca:	80 91 bc 20 	lds	r24, 0x20BC
    15ce:	90 91 bd 20 	lds	r25, 0x20BD
    15d2:	65 e0       	ldi	r22, 0x05	; 5
    15d4:	70 e0       	ldi	r23, 0x00	; 0
    15d6:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    15da:	89 2b       	or	r24, r25
    15dc:	b1 f4       	brne	.+44     	; 0x160a <__vector_14+0xa8>
	{
		TCTimingFlags |=Tick1ms;
    15de:	80 91 3c 20 	lds	r24, 0x203C
    15e2:	84 60       	ori	r24, 0x04	; 4
    15e4:	80 93 3c 20 	sts	0x203C, r24
		SensorWaitTimeHandler();							/* <Wait Time HANDLER OF SENSOR FSM (Timeout-Idle Timer-Revive Timer etc)> */
    15e8:	0e 94 72 03 	call	0x6e4	; 0x6e4 <SensorWaitTimeHandler>
		GroupHandler();
    15ec:	0e 94 53 05 	call	0xaa6	; 0xaa6 <GroupHandler>
		TWIWatchdog();
    15f0:	0e 94 63 03 	call	0x6c6	; 0x6c6 <TWIWatchdog>
		if(PCTXWaitAckNakTimer) {PCTXWaitAckNakTimer--;}
    15f4:	80 91 c1 20 	lds	r24, 0x20C1
    15f8:	90 91 c2 20 	lds	r25, 0x20C2
    15fc:	00 97       	sbiw	r24, 0x00	; 0
    15fe:	29 f0       	breq	.+10     	; 0x160a <__vector_14+0xa8>
    1600:	01 97       	sbiw	r24, 0x01	; 1
    1602:	80 93 c1 20 	sts	0x20C1, r24
    1606:	90 93 c2 20 	sts	0x20C2, r25
	}
	if(!(ticks % 25))
    160a:	80 91 bc 20 	lds	r24, 0x20BC
    160e:	90 91 bd 20 	lds	r25, 0x20BD
    1612:	69 e1       	ldi	r22, 0x19	; 25
    1614:	70 e0       	ldi	r23, 0x00	; 0
    1616:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    161a:	89 2b       	or	r24, r25
    161c:	31 f4       	brne	.+12     	; 0x162a <__vector_14+0xc8>
	{
		TCTimingFlags |=Tick5ms;
    161e:	80 91 3c 20 	lds	r24, 0x203C
    1622:	80 61       	ori	r24, 0x10	; 16
    1624:	80 93 3c 20 	sts	0x203C, r24
		WDT_Reset();
    1628:	a8 95       	wdr
	}
	if(!(ticks % 50)) {TCTimingFlags |=Tick10ms;}
    162a:	80 91 bc 20 	lds	r24, 0x20BC
    162e:	90 91 bd 20 	lds	r25, 0x20BD
    1632:	62 e3       	ldi	r22, 0x32	; 50
    1634:	70 e0       	ldi	r23, 0x00	; 0
    1636:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    163a:	89 2b       	or	r24, r25
    163c:	29 f4       	brne	.+10     	; 0x1648 <__vector_14+0xe6>
    163e:	80 91 3c 20 	lds	r24, 0x203C
    1642:	80 62       	ori	r24, 0x20	; 32
    1644:	80 93 3c 20 	sts	0x203C, r24
	if(!(ticks % 250)) {TCTimingFlags |=Tick50ms;}
    1648:	80 91 bc 20 	lds	r24, 0x20BC
    164c:	90 91 bd 20 	lds	r25, 0x20BD
    1650:	6a ef       	ldi	r22, 0xFA	; 250
    1652:	70 e0       	ldi	r23, 0x00	; 0
    1654:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    1658:	89 2b       	or	r24, r25
    165a:	29 f4       	brne	.+10     	; 0x1666 <__vector_14+0x104>
    165c:	80 91 3c 20 	lds	r24, 0x203C
    1660:	80 64       	ori	r24, 0x40	; 64
    1662:	80 93 3c 20 	sts	0x203C, r24
	if(!(ticks % 500)) {TCTimingFlags |=Tick100ms;}
    1666:	80 91 bc 20 	lds	r24, 0x20BC
    166a:	90 91 bd 20 	lds	r25, 0x20BD
    166e:	64 ef       	ldi	r22, 0xF4	; 244
    1670:	71 e0       	ldi	r23, 0x01	; 1
    1672:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    1676:	89 2b       	or	r24, r25
    1678:	29 f4       	brne	.+10     	; 0x1684 <__vector_14+0x122>
    167a:	80 91 3c 20 	lds	r24, 0x203C
    167e:	80 68       	ori	r24, 0x80	; 128
    1680:	80 93 3c 20 	sts	0x203C, r24
	if(!(ticks % 1000)) {TCTimingFlags |=Tick200ms;}
    1684:	80 91 bc 20 	lds	r24, 0x20BC
    1688:	90 91 bd 20 	lds	r25, 0x20BD
    168c:	68 ee       	ldi	r22, 0xE8	; 232
    168e:	73 e0       	ldi	r23, 0x03	; 3
    1690:	0e 94 24 0c 	call	0x1848	; 0x1848 <__udivmodhi4>
    1694:	89 2b       	or	r24, r25
    1696:	29 f4       	brne	.+10     	; 0x16a2 <__vector_14+0x140>
    1698:	80 91 3c 20 	lds	r24, 0x203C
    169c:	88 60       	ori	r24, 0x08	; 8
    169e:	80 93 3c 20 	sts	0x203C, r24
	
	/*<Service data transmission. Sending 1 byte every 200us> */
	data_transmitService();	
    16a2:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <data_transmitService>
	++ticks;
    16a6:	80 91 bc 20 	lds	r24, 0x20BC
    16aa:	90 91 bd 20 	lds	r25, 0x20BD
    16ae:	01 96       	adiw	r24, 0x01	; 1
    16b0:	80 93 bc 20 	sts	0x20BC, r24
    16b4:	90 93 bd 20 	sts	0x20BD, r25
	ticks %= 50000;
    16b8:	20 91 bc 20 	lds	r18, 0x20BC
    16bc:	30 91 bd 20 	lds	r19, 0x20BD
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	20 35       	cpi	r18, 0x50	; 80
    16c6:	43 ec       	ldi	r20, 0xC3	; 195
    16c8:	34 07       	cpc	r19, r20
    16ca:	10 f4       	brcc	.+4      	; 0x16d0 <__vector_14+0x16e>
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	60 e5       	ldi	r22, 0x50	; 80
    16d2:	73 ec       	ldi	r23, 0xC3	; 195
    16d4:	86 9f       	mul	r24, r22
    16d6:	a0 01       	movw	r20, r0
    16d8:	87 9f       	mul	r24, r23
    16da:	50 0d       	add	r21, r0
    16dc:	96 9f       	mul	r25, r22
    16de:	50 0d       	add	r21, r0
    16e0:	11 24       	eor	r1, r1
    16e2:	c9 01       	movw	r24, r18
    16e4:	84 1b       	sub	r24, r20
    16e6:	95 0b       	sbc	r25, r21
    16e8:	80 93 bc 20 	sts	0x20BC, r24
    16ec:	90 93 bd 20 	sts	0x20BD, r25
}

ISR(TCC0_OVF_vect)
{
	tcc0_ovf_interrupt_callback();
}
    16f0:	ff 91       	pop	r31
    16f2:	ef 91       	pop	r30
    16f4:	bf 91       	pop	r27
    16f6:	af 91       	pop	r26
    16f8:	9f 91       	pop	r25
    16fa:	8f 91       	pop	r24
    16fc:	7f 91       	pop	r23
    16fe:	6f 91       	pop	r22
    1700:	5f 91       	pop	r21
    1702:	4f 91       	pop	r20
    1704:	3f 91       	pop	r19
    1706:	2f 91       	pop	r18
    1708:	0f 90       	pop	r0
    170a:	0b be       	out	0x3b, r0	; 59
    170c:	0f 90       	pop	r0
    170e:	09 be       	out	0x39, r0	; 57
    1710:	0f 90       	pop	r0
    1712:	08 be       	out	0x38, r0	; 56
    1714:	0f 90       	pop	r0
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	0f 90       	pop	r0
    171a:	1f 90       	pop	r1
    171c:	18 95       	reti

0000171e <init_uC_clock>:
	__asm__ ("pop r16");
}

void init_uC_clock(void){
	/* <Swap Main Clock to Internal RC 2MHz(Default)> */
	CLKSYS_Enable(OSC_RC2MEN_bm); 									/* <Enable Internal RC Clock 2MHz> */
    171e:	80 91 50 00 	lds	r24, 0x0050
    1722:	81 60       	ori	r24, 0x01	; 1
    1724:	80 93 50 00 	sts	0x0050, r24
	do {} while(CLKSYS_IsReady(OSC_RC2MRDY_bm) == 0);				/* <Wait 2MHz RC Clock Stable> */
    1728:	80 91 51 00 	lds	r24, 0x0051
    172c:	80 ff       	sbrs	r24, 0
    172e:	fc cf       	rjmp	.-8      	; 0x1728 <init_uC_clock+0xa>
	CLKSYS_Main_ClockSource_Select(CLK_SCLKSEL_RC2M_gc);			/* <Select System Clock = Internal RC 2MHz> */
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Prescalers_Config(CLK_PSADIV_1_gc,CLK_PSBCDIV_1_1_gc);	/* <Prescale Divide by 1 ,Divide B by 1 and C by 1> */
    1736:	60 e0       	ldi	r22, 0x00	; 0
    1738:	80 e0       	ldi	r24, 0x00	; 0
    173a:	0e 94 66 01 	call	0x2cc	; 0x2cc <CLKSYS_Prescalers_Config>
	CLKSYS_Disable(OSC_XOSCEN_bm);									/* <Disable External XTAL Clock> */
    173e:	88 e0       	ldi	r24, 0x08	; 8
    1740:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <CLKSYS_Disable>
	CLKSYS_Disable(OSC_RC32MEN_bm);									/* <Disable Internal RC 32MHz> */
    1744:	82 e0       	ldi	r24, 0x02	; 2
    1746:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <CLKSYS_Disable>
	CLKSYS_Disable(OSC_RC32KEN_bm);									/* <Disable Internal RC 32KHz> */
    174a:	84 e0       	ldi	r24, 0x04	; 4
    174c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <CLKSYS_Disable>
	CLKSYS_Disable(OSC_PLLEN_bm);									/* <Disable PLL Clock> */
    1750:	80 e1       	ldi	r24, 0x10	; 16
    1752:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <CLKSYS_Disable>
	/* <Now System Clock is Ready = 2MHz> */

	/* <Start Config New Main Clock Source> */
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,			  			/* <Used Frequency Range 2-9MHz(8MHz)> */
    1756:	43 e0       	ldi	r20, 0x03	; 3
    1758:	61 e0       	ldi	r22, 0x01	; 1
    175a:	80 e4       	ldi	r24, 0x40	; 64
    175c:	0e 94 4c 01 	call	0x298	; 0x298 <CLKSYS_XOSC_Config>
						true,										/* <Used High-quality watch crystals> */
						OSC_XOSCSEL_XTAL_256CLK_gc					/* <Select 8MHz XTAL + Startup 256 Cycle> */
						);		  		
	CLKSYS_Enable(OSC_XOSCEN_bm);						  			/* <Enable External Clock> */
    1760:	80 91 50 00 	lds	r24, 0x0050
    1764:	88 60       	ori	r24, 0x08	; 8
    1766:	80 93 50 00 	sts	0x0050, r24
	do {} while (CLKSYS_IsReady(OSC_XOSCRDY_bm) == 0);  			/* <Wait Clock is Stable> */
    176a:	80 91 51 00 	lds	r24, 0x0051
    176e:	83 ff       	sbrs	r24, 3
    1770:	fc cf       	rjmp	.-8      	; 0x176a <init_uC_clock+0x4c>
	CLKSYS_Prescalers_Config(CLK_PSADIV_1_gc,CLK_PSBCDIV_1_1_gc);	/* <Prescale Divide by 1 ,Divide B by 1 and C by 1> */
    1772:	60 e0       	ldi	r22, 0x00	; 0
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	0e 94 66 01 	call	0x2cc	; 0x2cc <CLKSYS_Prescalers_Config>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 8 );  					/* <External Oscillator(8MHz) x 8 = 64MHz> */
    177a:	68 e0       	ldi	r22, 0x08	; 8
    177c:	80 ec       	ldi	r24, 0xC0	; 192
    177e:	0e 94 56 01 	call	0x2ac	; 0x2ac <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );									/* <Enable PLL> */
    1782:	80 91 50 00 	lds	r24, 0x0050
    1786:	80 61       	ori	r24, 0x10	; 16
    1788:	80 93 50 00 	sts	0x0050, r24
	CLKSYS_Prescalers_Config(CLK_PSADIV_1_gc,CLK_PSBCDIV_1_2_gc);	/* <Prescale Divide by 1 ,Divide B by 1 and C by 2> */
    178c:	61 e0       	ldi	r22, 0x01	; 1
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	0e 94 66 01 	call	0x2cc	; 0x2cc <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady(OSC_PLLRDY_bm ) == 0);				/* <Wait PLL ready> */
    1794:	80 91 51 00 	lds	r24, 0x0051
    1798:	84 ff       	sbrs	r24, 4
    179a:	fc cf       	rjmp	.-8      	; 0x1794 <init_uC_clock+0x76>
	CLKSYS_Main_ClockSource_Select(CLK_SCLKSEL_PLL_gc);				/* <Select System Clock = Phase Locked Loop(32MHz)> */
    179c:	84 e0       	ldi	r24, 0x04	; 4
    179e:	0c 94 6b 01 	jmp	0x2d6	; 0x2d6 <CLKSYS_Main_ClockSource_Select>

000017a2 <_startup_system_init>:
	Initialize two Analog to Digital Signal Inputs. (ADCB)
	Initialize Encoder.
 */
void _startup_system_init(void)
{
	init_uC_clock();											/* <Initialize Fsys clock to use external XTAL and PLL for Fsys=32MHz> */
    17a2:	0e 94 8f 0b 	call	0x171e	; 0x171e <init_uC_clock>
	WDT_EnableAndSetTimeout(WDT_PER_8CLK_gc);					/* <Initialize WDT module with 8ms Timeout> */
    17a6:	80 e0       	ldi	r24, 0x00	; 0
    17a8:	0e 94 76 02 	call	0x4ec	; 0x4ec <WDT_EnableAndSetTimeout>
	
	/*============================Initialize TCC0 interrupt every 200us===============================*/
	TC_SetPeriod( &TCC0, 799 );									/* <Set period/TOP value> */
    17ac:	8f e1       	ldi	r24, 0x1F	; 31
    17ae:	93 e0       	ldi	r25, 0x03	; 3
    17b0:	e0 e0       	ldi	r30, 0x00	; 0
    17b2:	f8 e0       	ldi	r31, 0x08	; 8
    17b4:	86 a3       	std	Z+38, r24	; 0x26
    17b6:	97 a3       	std	Z+39, r25	; 0x27
	TC0_ConfigWGM( &TCC0, TC_WGMODE_SS_gc );					/* <Configure the TC for single slope mode> */
    17b8:	63 e0       	ldi	r22, 0x03	; 3
    17ba:	80 e0       	ldi	r24, 0x00	; 0
    17bc:	98 e0       	ldi	r25, 0x08	; 8
    17be:	0e 94 84 01 	call	0x308	; 0x308 <TC0_ConfigWGM>
	TC0_SetOverflowIntLevel( &TCC0, TC_OVFINTLVL_LO_gc );		/* <Enable overflow interrupt at low level> */
    17c2:	61 e0       	ldi	r22, 0x01	; 1
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    17c6:	98 e0       	ldi	r25, 0x08	; 8
    17c8:	0e 94 8a 01 	call	0x314	; 0x314 <TC0_SetOverflowIntLevel>
	TC0_ConfigClockSource( &TCC0, TC_CLKSEL_DIV8_gc );			/* <Select clock source> */
    17cc:	64 e0       	ldi	r22, 0x04	; 4
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	98 e0       	ldi	r25, 0x08	; 8
    17d2:	0e 94 7e 01 	call	0x2fc	; 0x2fc <TC0_ConfigClockSource>
	/*================================================================================================*/
	init_uart();												/* <Initialize USART> */
    17d6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <init_uart>
	
	/*================================ Initialize TWI master =========================================*/
	TWI_MasterInit(&twiMaster,
    17da:	20 ed       	ldi	r18, 0xD0	; 208
    17dc:	40 e4       	ldi	r20, 0x40	; 64
    17de:	60 e8       	ldi	r22, 0x80	; 128
    17e0:	74 e0       	ldi	r23, 0x04	; 4
    17e2:	82 e7       	ldi	r24, 0x72	; 114
    17e4:	91 e2       	ldi	r25, 0x21	; 33
    17e6:	0e 94 90 01 	call	0x320	; 0x320 <TWI_MasterInit>
	&TWIC,TWI_MASTER_INTLVL_LO_gc,
	TWI_BAUDSETTING);
	/*================================================================================================*/
	PMIC.CTRL |= PMIC_LOLVLEN_bm;								/* <Enable LO interrupt level> */
    17ea:	e0 ea       	ldi	r30, 0xA0	; 160
    17ec:	f0 e0       	ldi	r31, 0x00	; 0
    17ee:	82 81       	ldd	r24, Z+2	; 0x02
    17f0:	81 60       	ori	r24, 0x01	; 1
    17f2:	82 83       	std	Z+2, r24	; 0x02
	
	/*================================ Enable ADCB CH0 & CH1 =========================================*/
	PORTB.OUT=0x00;
    17f4:	e0 e2       	ldi	r30, 0x20	; 32
    17f6:	f6 e0       	ldi	r31, 0x06	; 6
    17f8:	14 82       	std	Z+4, r1	; 0x04
	PORTB.DIR = 0x00;											/* <Configure PORTB as input> */
    17fa:	10 82       	st	Z, r1
	ADCB.CTRLA |= 0x1;											/* <Enable ADCB> */
    17fc:	e0 e4       	ldi	r30, 0x40	; 64
    17fe:	f2 e0       	ldi	r31, 0x02	; 2
    1800:	80 81       	ld	r24, Z
    1802:	81 60       	ori	r24, 0x01	; 1
    1804:	80 83       	st	Z, r24
	ADCB.CTRLB = ADC_RESOLUTION_12BIT_gc; 						/* <Set 12 bit conversion> */
    1806:	11 82       	std	Z+1, r1	; 0x01
	ADCB.CTRLB |= ADC_FREERUN_bm;								/* <Enable Freerunning mode> */
    1808:	81 81       	ldd	r24, Z+1	; 0x01
    180a:	88 60       	ori	r24, 0x08	; 8
    180c:	81 83       	std	Z+1, r24	; 0x01
	ADCB.REFCTRL = ADC_REFSEL_AREFB_gc;							/* <External reference from AREF pin on PORT B> */
    180e:	80 e3       	ldi	r24, 0x30	; 48
    1810:	82 83       	std	Z+2, r24	; 0x02
	ADCB.PRESCALER = ADC_PRESCALER_DIV512_gc; 					/* <Peripheral clk/512 (32MHz/512=62.5kHz)> */
    1812:	87 e0       	ldi	r24, 0x07	; 7
    1814:	84 83       	std	Z+4, r24	; 0x04
	ADCB.CH0.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; 			/* <Single Ended> */
    1816:	81 e0       	ldi	r24, 0x01	; 1
    1818:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH1.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc; 			/* <Single Ended> */
    181a:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc; 					/* <ADC_CHANNEL0 Converts Analog Input PORTB:1 (Motor Battery)> */
    181c:	88 e0       	ldi	r24, 0x08	; 8
    181e:	81 a3       	std	Z+33, r24	; 0x21
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN3_gc; 					/* <ADC_CHANNEL1 Converts Analog Input PORTB:3 (PSU Battery)> */
    1820:	88 e1       	ldi	r24, 0x18	; 24
    1822:	81 a7       	std	Z+41, r24	; 0x29
	ADCB.EVCTRL = ADC_SWEEP_01_gc;								/* <SWEEP mode 01 selected> */
    1824:	80 e4       	ldi	r24, 0x40	; 64
    1826:	83 83       	std	Z+3, r24	; 0x03
	/*================================================================================================*/
	
	init_encoder(&_encoder);
    1828:	8d ec       	ldi	r24, 0xCD	; 205
    182a:	90 e2       	ldi	r25, 0x20	; 32
    182c:	0c 94 80 02 	jmp	0x500	; 0x500 <init_encoder>

00001830 <__udivmodqi4>:
    1830:	99 1b       	sub	r25, r25
    1832:	79 e0       	ldi	r23, 0x09	; 9
    1834:	04 c0       	rjmp	.+8      	; 0x183e <__udivmodqi4_ep>

00001836 <__udivmodqi4_loop>:
    1836:	99 1f       	adc	r25, r25
    1838:	96 17       	cp	r25, r22
    183a:	08 f0       	brcs	.+2      	; 0x183e <__udivmodqi4_ep>
    183c:	96 1b       	sub	r25, r22

0000183e <__udivmodqi4_ep>:
    183e:	88 1f       	adc	r24, r24
    1840:	7a 95       	dec	r23
    1842:	c9 f7       	brne	.-14     	; 0x1836 <__udivmodqi4_loop>
    1844:	80 95       	com	r24
    1846:	08 95       	ret

00001848 <__udivmodhi4>:
    1848:	aa 1b       	sub	r26, r26
    184a:	bb 1b       	sub	r27, r27
    184c:	51 e1       	ldi	r21, 0x11	; 17
    184e:	07 c0       	rjmp	.+14     	; 0x185e <__udivmodhi4_ep>

00001850 <__udivmodhi4_loop>:
    1850:	aa 1f       	adc	r26, r26
    1852:	bb 1f       	adc	r27, r27
    1854:	a6 17       	cp	r26, r22
    1856:	b7 07       	cpc	r27, r23
    1858:	10 f0       	brcs	.+4      	; 0x185e <__udivmodhi4_ep>
    185a:	a6 1b       	sub	r26, r22
    185c:	b7 0b       	sbc	r27, r23

0000185e <__udivmodhi4_ep>:
    185e:	88 1f       	adc	r24, r24
    1860:	99 1f       	adc	r25, r25
    1862:	5a 95       	dec	r21
    1864:	a9 f7       	brne	.-22     	; 0x1850 <__udivmodhi4_loop>
    1866:	80 95       	com	r24
    1868:	90 95       	com	r25
    186a:	bc 01       	movw	r22, r24
    186c:	cd 01       	movw	r24, r26
    186e:	08 95       	ret

00001870 <__tablejump2__>:
    1870:	ee 0f       	add	r30, r30
    1872:	ff 1f       	adc	r31, r31

00001874 <__tablejump__>:
    1874:	05 90       	lpm	r0, Z+
    1876:	f4 91       	lpm	r31, Z
    1878:	e0 2d       	mov	r30, r0
    187a:	19 94       	eijmp

0000187c <malloc>:
    187c:	cf 93       	push	r28
    187e:	df 93       	push	r29
    1880:	82 30       	cpi	r24, 0x02	; 2
    1882:	91 05       	cpc	r25, r1
    1884:	10 f4       	brcc	.+4      	; 0x188a <malloc+0xe>
    1886:	82 e0       	ldi	r24, 0x02	; 2
    1888:	90 e0       	ldi	r25, 0x00	; 0
    188a:	e0 91 99 21 	lds	r30, 0x2199
    188e:	f0 91 9a 21 	lds	r31, 0x219A
    1892:	20 e0       	ldi	r18, 0x00	; 0
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	a0 e0       	ldi	r26, 0x00	; 0
    1898:	b0 e0       	ldi	r27, 0x00	; 0
    189a:	30 97       	sbiw	r30, 0x00	; 0
    189c:	39 f1       	breq	.+78     	; 0x18ec <malloc+0x70>
    189e:	40 81       	ld	r20, Z
    18a0:	51 81       	ldd	r21, Z+1	; 0x01
    18a2:	48 17       	cp	r20, r24
    18a4:	59 07       	cpc	r21, r25
    18a6:	b8 f0       	brcs	.+46     	; 0x18d6 <malloc+0x5a>
    18a8:	48 17       	cp	r20, r24
    18aa:	59 07       	cpc	r21, r25
    18ac:	71 f4       	brne	.+28     	; 0x18ca <malloc+0x4e>
    18ae:	82 81       	ldd	r24, Z+2	; 0x02
    18b0:	93 81       	ldd	r25, Z+3	; 0x03
    18b2:	10 97       	sbiw	r26, 0x00	; 0
    18b4:	29 f0       	breq	.+10     	; 0x18c0 <malloc+0x44>
    18b6:	12 96       	adiw	r26, 0x02	; 2
    18b8:	8d 93       	st	X+, r24
    18ba:	9c 93       	st	X, r25
    18bc:	13 97       	sbiw	r26, 0x03	; 3
    18be:	2c c0       	rjmp	.+88     	; 0x1918 <malloc+0x9c>
    18c0:	80 93 99 21 	sts	0x2199, r24
    18c4:	90 93 9a 21 	sts	0x219A, r25
    18c8:	27 c0       	rjmp	.+78     	; 0x1918 <malloc+0x9c>
    18ca:	21 15       	cp	r18, r1
    18cc:	31 05       	cpc	r19, r1
    18ce:	31 f0       	breq	.+12     	; 0x18dc <malloc+0x60>
    18d0:	42 17       	cp	r20, r18
    18d2:	53 07       	cpc	r21, r19
    18d4:	18 f0       	brcs	.+6      	; 0x18dc <malloc+0x60>
    18d6:	a9 01       	movw	r20, r18
    18d8:	db 01       	movw	r26, r22
    18da:	01 c0       	rjmp	.+2      	; 0x18de <malloc+0x62>
    18dc:	ef 01       	movw	r28, r30
    18de:	9a 01       	movw	r18, r20
    18e0:	bd 01       	movw	r22, r26
    18e2:	df 01       	movw	r26, r30
    18e4:	02 80       	ldd	r0, Z+2	; 0x02
    18e6:	f3 81       	ldd	r31, Z+3	; 0x03
    18e8:	e0 2d       	mov	r30, r0
    18ea:	d7 cf       	rjmp	.-82     	; 0x189a <malloc+0x1e>
    18ec:	21 15       	cp	r18, r1
    18ee:	31 05       	cpc	r19, r1
    18f0:	f9 f0       	breq	.+62     	; 0x1930 <malloc+0xb4>
    18f2:	28 1b       	sub	r18, r24
    18f4:	39 0b       	sbc	r19, r25
    18f6:	24 30       	cpi	r18, 0x04	; 4
    18f8:	31 05       	cpc	r19, r1
    18fa:	80 f4       	brcc	.+32     	; 0x191c <malloc+0xa0>
    18fc:	8a 81       	ldd	r24, Y+2	; 0x02
    18fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1900:	61 15       	cp	r22, r1
    1902:	71 05       	cpc	r23, r1
    1904:	21 f0       	breq	.+8      	; 0x190e <malloc+0x92>
    1906:	fb 01       	movw	r30, r22
    1908:	82 83       	std	Z+2, r24	; 0x02
    190a:	93 83       	std	Z+3, r25	; 0x03
    190c:	04 c0       	rjmp	.+8      	; 0x1916 <malloc+0x9a>
    190e:	80 93 99 21 	sts	0x2199, r24
    1912:	90 93 9a 21 	sts	0x219A, r25
    1916:	fe 01       	movw	r30, r28
    1918:	32 96       	adiw	r30, 0x02	; 2
    191a:	44 c0       	rjmp	.+136    	; 0x19a4 <malloc+0x128>
    191c:	fe 01       	movw	r30, r28
    191e:	e2 0f       	add	r30, r18
    1920:	f3 1f       	adc	r31, r19
    1922:	81 93       	st	Z+, r24
    1924:	91 93       	st	Z+, r25
    1926:	22 50       	subi	r18, 0x02	; 2
    1928:	31 09       	sbc	r19, r1
    192a:	28 83       	st	Y, r18
    192c:	39 83       	std	Y+1, r19	; 0x01
    192e:	3a c0       	rjmp	.+116    	; 0x19a4 <malloc+0x128>
    1930:	20 91 97 21 	lds	r18, 0x2197
    1934:	30 91 98 21 	lds	r19, 0x2198
    1938:	23 2b       	or	r18, r19
    193a:	41 f4       	brne	.+16     	; 0x194c <malloc+0xd0>
    193c:	20 91 02 20 	lds	r18, 0x2002
    1940:	30 91 03 20 	lds	r19, 0x2003
    1944:	20 93 97 21 	sts	0x2197, r18
    1948:	30 93 98 21 	sts	0x2198, r19
    194c:	20 91 00 20 	lds	r18, 0x2000
    1950:	30 91 01 20 	lds	r19, 0x2001
    1954:	21 15       	cp	r18, r1
    1956:	31 05       	cpc	r19, r1
    1958:	41 f4       	brne	.+16     	; 0x196a <malloc+0xee>
    195a:	2d b7       	in	r18, 0x3d	; 61
    195c:	3e b7       	in	r19, 0x3e	; 62
    195e:	40 91 04 20 	lds	r20, 0x2004
    1962:	50 91 05 20 	lds	r21, 0x2005
    1966:	24 1b       	sub	r18, r20
    1968:	35 0b       	sbc	r19, r21
    196a:	e0 91 97 21 	lds	r30, 0x2197
    196e:	f0 91 98 21 	lds	r31, 0x2198
    1972:	e2 17       	cp	r30, r18
    1974:	f3 07       	cpc	r31, r19
    1976:	a0 f4       	brcc	.+40     	; 0x19a0 <malloc+0x124>
    1978:	2e 1b       	sub	r18, r30
    197a:	3f 0b       	sbc	r19, r31
    197c:	28 17       	cp	r18, r24
    197e:	39 07       	cpc	r19, r25
    1980:	78 f0       	brcs	.+30     	; 0x19a0 <malloc+0x124>
    1982:	ac 01       	movw	r20, r24
    1984:	4e 5f       	subi	r20, 0xFE	; 254
    1986:	5f 4f       	sbci	r21, 0xFF	; 255
    1988:	24 17       	cp	r18, r20
    198a:	35 07       	cpc	r19, r21
    198c:	48 f0       	brcs	.+18     	; 0x19a0 <malloc+0x124>
    198e:	4e 0f       	add	r20, r30
    1990:	5f 1f       	adc	r21, r31
    1992:	40 93 97 21 	sts	0x2197, r20
    1996:	50 93 98 21 	sts	0x2198, r21
    199a:	81 93       	st	Z+, r24
    199c:	91 93       	st	Z+, r25
    199e:	02 c0       	rjmp	.+4      	; 0x19a4 <malloc+0x128>
    19a0:	e0 e0       	ldi	r30, 0x00	; 0
    19a2:	f0 e0       	ldi	r31, 0x00	; 0
    19a4:	cf 01       	movw	r24, r30
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	08 95       	ret

000019ac <free>:
    19ac:	cf 93       	push	r28
    19ae:	df 93       	push	r29
    19b0:	00 97       	sbiw	r24, 0x00	; 0
    19b2:	09 f4       	brne	.+2      	; 0x19b6 <free+0xa>
    19b4:	87 c0       	rjmp	.+270    	; 0x1ac4 <free+0x118>
    19b6:	fc 01       	movw	r30, r24
    19b8:	32 97       	sbiw	r30, 0x02	; 2
    19ba:	12 82       	std	Z+2, r1	; 0x02
    19bc:	13 82       	std	Z+3, r1	; 0x03
    19be:	c0 91 99 21 	lds	r28, 0x2199
    19c2:	d0 91 9a 21 	lds	r29, 0x219A
    19c6:	20 97       	sbiw	r28, 0x00	; 0
    19c8:	81 f4       	brne	.+32     	; 0x19ea <free+0x3e>
    19ca:	20 81       	ld	r18, Z
    19cc:	31 81       	ldd	r19, Z+1	; 0x01
    19ce:	28 0f       	add	r18, r24
    19d0:	39 1f       	adc	r19, r25
    19d2:	80 91 97 21 	lds	r24, 0x2197
    19d6:	90 91 98 21 	lds	r25, 0x2198
    19da:	82 17       	cp	r24, r18
    19dc:	93 07       	cpc	r25, r19
    19de:	79 f5       	brne	.+94     	; 0x1a3e <free+0x92>
    19e0:	e0 93 97 21 	sts	0x2197, r30
    19e4:	f0 93 98 21 	sts	0x2198, r31
    19e8:	6d c0       	rjmp	.+218    	; 0x1ac4 <free+0x118>
    19ea:	de 01       	movw	r26, r28
    19ec:	20 e0       	ldi	r18, 0x00	; 0
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	ae 17       	cp	r26, r30
    19f2:	bf 07       	cpc	r27, r31
    19f4:	50 f4       	brcc	.+20     	; 0x1a0a <free+0x5e>
    19f6:	12 96       	adiw	r26, 0x02	; 2
    19f8:	4d 91       	ld	r20, X+
    19fa:	5c 91       	ld	r21, X
    19fc:	13 97       	sbiw	r26, 0x03	; 3
    19fe:	9d 01       	movw	r18, r26
    1a00:	41 15       	cp	r20, r1
    1a02:	51 05       	cpc	r21, r1
    1a04:	09 f1       	breq	.+66     	; 0x1a48 <free+0x9c>
    1a06:	da 01       	movw	r26, r20
    1a08:	f3 cf       	rjmp	.-26     	; 0x19f0 <free+0x44>
    1a0a:	a2 83       	std	Z+2, r26	; 0x02
    1a0c:	b3 83       	std	Z+3, r27	; 0x03
    1a0e:	40 81       	ld	r20, Z
    1a10:	51 81       	ldd	r21, Z+1	; 0x01
    1a12:	84 0f       	add	r24, r20
    1a14:	95 1f       	adc	r25, r21
    1a16:	8a 17       	cp	r24, r26
    1a18:	9b 07       	cpc	r25, r27
    1a1a:	71 f4       	brne	.+28     	; 0x1a38 <free+0x8c>
    1a1c:	8d 91       	ld	r24, X+
    1a1e:	9c 91       	ld	r25, X
    1a20:	11 97       	sbiw	r26, 0x01	; 1
    1a22:	84 0f       	add	r24, r20
    1a24:	95 1f       	adc	r25, r21
    1a26:	02 96       	adiw	r24, 0x02	; 2
    1a28:	80 83       	st	Z, r24
    1a2a:	91 83       	std	Z+1, r25	; 0x01
    1a2c:	12 96       	adiw	r26, 0x02	; 2
    1a2e:	8d 91       	ld	r24, X+
    1a30:	9c 91       	ld	r25, X
    1a32:	13 97       	sbiw	r26, 0x03	; 3
    1a34:	82 83       	std	Z+2, r24	; 0x02
    1a36:	93 83       	std	Z+3, r25	; 0x03
    1a38:	21 15       	cp	r18, r1
    1a3a:	31 05       	cpc	r19, r1
    1a3c:	29 f4       	brne	.+10     	; 0x1a48 <free+0x9c>
    1a3e:	e0 93 99 21 	sts	0x2199, r30
    1a42:	f0 93 9a 21 	sts	0x219A, r31
    1a46:	3e c0       	rjmp	.+124    	; 0x1ac4 <free+0x118>
    1a48:	d9 01       	movw	r26, r18
    1a4a:	12 96       	adiw	r26, 0x02	; 2
    1a4c:	ed 93       	st	X+, r30
    1a4e:	fc 93       	st	X, r31
    1a50:	13 97       	sbiw	r26, 0x03	; 3
    1a52:	4d 91       	ld	r20, X+
    1a54:	5d 91       	ld	r21, X+
    1a56:	a4 0f       	add	r26, r20
    1a58:	b5 1f       	adc	r27, r21
    1a5a:	ea 17       	cp	r30, r26
    1a5c:	fb 07       	cpc	r31, r27
    1a5e:	79 f4       	brne	.+30     	; 0x1a7e <free+0xd2>
    1a60:	80 81       	ld	r24, Z
    1a62:	91 81       	ldd	r25, Z+1	; 0x01
    1a64:	84 0f       	add	r24, r20
    1a66:	95 1f       	adc	r25, r21
    1a68:	02 96       	adiw	r24, 0x02	; 2
    1a6a:	d9 01       	movw	r26, r18
    1a6c:	8d 93       	st	X+, r24
    1a6e:	9c 93       	st	X, r25
    1a70:	11 97       	sbiw	r26, 0x01	; 1
    1a72:	82 81       	ldd	r24, Z+2	; 0x02
    1a74:	93 81       	ldd	r25, Z+3	; 0x03
    1a76:	12 96       	adiw	r26, 0x02	; 2
    1a78:	8d 93       	st	X+, r24
    1a7a:	9c 93       	st	X, r25
    1a7c:	13 97       	sbiw	r26, 0x03	; 3
    1a7e:	e0 e0       	ldi	r30, 0x00	; 0
    1a80:	f0 e0       	ldi	r31, 0x00	; 0
    1a82:	8a 81       	ldd	r24, Y+2	; 0x02
    1a84:	9b 81       	ldd	r25, Y+3	; 0x03
    1a86:	00 97       	sbiw	r24, 0x00	; 0
    1a88:	19 f0       	breq	.+6      	; 0x1a90 <free+0xe4>
    1a8a:	fe 01       	movw	r30, r28
    1a8c:	ec 01       	movw	r28, r24
    1a8e:	f9 cf       	rjmp	.-14     	; 0x1a82 <free+0xd6>
    1a90:	ce 01       	movw	r24, r28
    1a92:	02 96       	adiw	r24, 0x02	; 2
    1a94:	28 81       	ld	r18, Y
    1a96:	39 81       	ldd	r19, Y+1	; 0x01
    1a98:	82 0f       	add	r24, r18
    1a9a:	93 1f       	adc	r25, r19
    1a9c:	20 91 97 21 	lds	r18, 0x2197
    1aa0:	30 91 98 21 	lds	r19, 0x2198
    1aa4:	28 17       	cp	r18, r24
    1aa6:	39 07       	cpc	r19, r25
    1aa8:	69 f4       	brne	.+26     	; 0x1ac4 <free+0x118>
    1aaa:	30 97       	sbiw	r30, 0x00	; 0
    1aac:	29 f4       	brne	.+10     	; 0x1ab8 <free+0x10c>
    1aae:	10 92 99 21 	sts	0x2199, r1
    1ab2:	10 92 9a 21 	sts	0x219A, r1
    1ab6:	02 c0       	rjmp	.+4      	; 0x1abc <free+0x110>
    1ab8:	12 82       	std	Z+2, r1	; 0x02
    1aba:	13 82       	std	Z+3, r1	; 0x03
    1abc:	c0 93 97 21 	sts	0x2197, r28
    1ac0:	d0 93 98 21 	sts	0x2198, r29
    1ac4:	df 91       	pop	r29
    1ac6:	cf 91       	pop	r28
    1ac8:	08 95       	ret

00001aca <_exit>:
    1aca:	f8 94       	cli

00001acc <__stop_program>:
    1acc:	ff cf       	rjmp	.-2      	; 0x1acc <__stop_program>
